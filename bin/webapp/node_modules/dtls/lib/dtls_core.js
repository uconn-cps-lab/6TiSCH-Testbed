var dtls_config               = require('dtls/dtls_config.js');
var memset                    = require('dtls/dtls_config').memset;
var memcpy                    = require('dtls/dtls_config').memcpy;
var memcmp                    = require('dtls/dtls_config').memcmp;
var dtls_int_to_uint8         = require('dtls/dtls_config').dtls_int_to_uint8;
var dtls_int_to_uint16        = require('dtls/dtls_config').dtls_int_to_uint16;
var dtls_int_to_uint24        = require('dtls/dtls_config').dtls_int_to_uint24;
var dtls_int_to_uint32        = require('dtls/dtls_config').dtls_int_to_uint32;
var dtls_int_to_uint48        = require('dtls/dtls_config').dtls_int_to_uint48;
var dtls_uint8_to_int         = require('dtls/dtls_config').dtls_uint8_to_int;
var dtls_uint16_to_int        = require('dtls/dtls_config').dtls_uint16_to_int;
var dtls_uint24_to_int        = require('dtls/dtls_config').dtls_uint24_to_int;
var dtls_uint32_to_int        = require('dtls/dtls_config').dtls_uint32_to_int;
var dtls_info                 = require('dtls/dtls_config').dtls_info;
var dtls_warn                 = require('dtls/dtls_config').dtls_warn;
var dtls_debug                = require('dtls/dtls_config').dtls_debug;
var dtls_crit                 = require('dtls/dtls_config').dtls_crit;
var dtls_alert                = require('dtls/dtls_config').dtls_alert;
var dtls_prng                 = require('dtls/dtls_config').dtls_prng;   //DTLS_ECC_FEATURE
var netq_insert_node          = require('dtls/lib/netq').netq_insert_node;
var netq_node_free            = require('dtls/lib/netq').netq_node_free;
var netq_node_find            = require('dtls/lib/netq').netq_node_find;
var dtls_encrypt              = require('dtls/lib/crypto').dtls_encrypt;
var dtls_prf                  = require('dtls/lib/crypto').dtls_prf;
var dtls_decrypt              = require('dtls/lib/crypto').dtls_decrypt;
var dtls_ec_key_from_uint32_asn1    = require('dtls/lib/crypto').dtls_ec_key_from_uint32_asn1;
var dtls_ecdh_pre_master_secret     = require('dtls/lib/crypto').dtls_ecdh_pre_master_secret;
var dtls_ecdsa_generate_key         = require('dtls/lib/crypto').dtls_ecdsa_generate_key;
var dtls_ecdsa_create_sig_hash      = require('dtls/lib/crypto').dtls_ecdsa_create_sig_hash;
var dtls_ecdsa_create_sig           = require('dtls/lib/crypto').dtls_ecdsa_create_sig;
var dtls_ecdsa_verify_sig_hash      = require('dtls/lib/crypto').dtls_ecdsa_verify_sig_hash;
var dtls_ecdsa_verify_sig           = require('dtls/lib/crypto').dtls_ecdsa_verify_sig;
var sha256_initial_hash_value = require('dtls/lib/sha2').sha256_initial_hash_value;
var SHA256_Update             = require('dtls/lib/sha2').SHA256_Update;
var dtls_hash_finalize        = require('dtls/lib/hmac').dtls_hash_finalize;

//DTLS_ECC_FEATURE begin
//* first part of Raw public key, the is the start of the Subject Public Key 
var cert_asn1_header = 
[
    0x30, 0x59, //* SEQUENCE, length 89 bytes 
    0x30, 0x13, //* SEQUENCE, length 19 bytes 
    0x06, 0x07, //* OBJECT IDENTIFIER ecPublicKey (1 2 840 10045 2 1) 
    0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01,
    0x06, 0x08, //* OBJECT IDENTIFIER prime256v1 (1 2 840 10045 3 1 7) 
    0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07,
    0x03, 0x42, 0x00, //* BIT STRING, length 66 bytes, 0 bits unused 
    0x04  //* uncompressed, followed by the r und s values of the public key 
];
 //DTLS_ECC_FEATURE end
function verify_ext_eliptic_curves(data, data_length)
{
   var i;
   var idx = 0;
   var curve_name;

   //* length of curve list 
   i = dtls_uint16_to_int(data);
   idx += 2;
   if (i + 2 != data_length) 
   {
      dtls_warn("the list of the supported elliptic curves should be tls extension length - 2");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }

   for (i = data_length - 2; i > 0; i -= 2) 
   {
   //* check if this curve is supported 
      curve_name = dtls_uint16_to_int(data.slice(idx, idx+2));
      idx += 2;

      if (curve_name == dtls_config.TLS_EXT_ELLIPTIC_CURVES_SECP256R1)
         return 0;
   }

   dtls_warn("no supported elliptic curve found");
   return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
}

function verify_ext_cert_type(data, data_length)
{
   var i;
   var cert_type;
   var idx  = 0;

   //* length of cert type list 
   i = dtls_uint8_to_int(data);
   idx += 1;
   if (i + 1 != data_length) 
   {
      dtls_warn("the list of the supported certificate types should be tls extension length - 1");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }

   for (i = data_length - 1; i > 0; i -= 1) 
   {
      //* check if this cert type is supported 
      cert_type = dtls_uint8_to_int(data.slice(i, i+1));
      idx += 1;

      if (cert_type == dtls_config.TLS_CERT_TYPE_RAW_PUBLIC_KEY)
         return 0;
   }

   dtls_warn("no supported certificate type found");
   return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
}

function verify_ext_ec_point_formats(data, data_length)
{
   var i;
   var cert_type;
   var idx = 0;

   //* length of ec_point_formats list 
   i = dtls_uint8_to_int(data);
   idx += 1;
   if (i + 1 != data_length) 
   {
      dtls_warn("the list of the supported ec_point_formats should be tls extension length - 1");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }

   for (i = data_length - 1; i > 0; i -= 1) 
   {
      //* check if this ec_point_format is supported 
      cert_type = dtls_uint8_to_int(data.slice(idx, idx+1));
      idx += 1;

      if (cert_type == dtls_config.TLS_EXT_EC_POINT_FORMATS_UNCOMPRESSED)
         return 0;
   }

   dtls_warn("no supported ec_point_format found");
   return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
}

function dtls_retransmit(node)
{
   dtls_debug("dtls_retransmit() enter");
   if (node)
   {
      var session = node.session;
      //* re-initialize timeout when maximum number of retransmissions are not reached yet 
      if (node.retransmit_cnt < dtls_config.DTLS_DEFAULT_MAX_RETRANSMIT) 
      {
         var err;
         var data = node.data;
   
         var now = dtls_ticks();
         node.retransmit_cnt++;
         node.t = now + (node.timeout * Math.pow(2, node.retransmit_cnt));
         netq_insert_node(node);
         etimer_set(node);
           
         if (node.type == dtls_config.DTLS_CT_HANDSHAKE) 
         {
            var hs_header = DTLS_HANDSHAKE_HEADER(data);
   
            dtls_info("** retransmit handshake packet of type: " +
                   dtls_handshake_type_to_name(hs_header.msg_type) + " (" +  hs_header.msg_type + ")");
         } 
         else 
         {
            dtls_info("** retransmit packet");
         }
           
         var sendbuf = dtls_prepare_record(node.session, node.type, data);
         if (!sendbuf) 
         {
            dtls_warn("can not retransmit packet");
            return;
         }
         if (session.h && session.h.write)
         {
        	 session.h.write(session, sendbuf);
         }
         return;
      }
   
      /* no more retransmissions, remove node from system */
       
      dtls_info("**Retransmit MAX reached, removed transaction");
      dtls_destroy_peer(node.session, 1);
   
      /* And finally delete the node */
      netq_node_free(node);
   }
   dtls_debug("dtls_retransmit() exit");
}

function dtls_get_epoch(H)
{
   return dtls_config.dtls_uint16_to_int(H.epoch);
}

function decrypt_verify(session, packet, length)
{
   var cleartext = packet.slice(dtls_config.DTLS_RH_LENGTH, length); 
   var ctxtoffset = 0;
   var header = DTLS_RECORD_HEADER(packet);
   var security = dtls_security_params_epoch(session, dtls_get_epoch(header));
   var clen = cleartext.length;
 
   if (!security) 
   {
      dtls_config.dtls_alert("No security context for epoch: " + dtls_get_epoch(header));
      return null;
   }

   if (security.cipher == dtls_config.TLS_NULL_WITH_NULL_NULL) 
   {
      //* no cipher suite selected 
      return cleartext;
   } 
   else 
   { 
      //* TLS_PSK_WITH_AES_128_CCM_8 or TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 
      //** 
       //* length of additional_data for the AEAD cipher which consists of
       //* seq_num(2+6) + type(1) + version(2) + length(2)
       //
      var A_DATA_LEN = 13;
      var nonce = [];
      var A_DATA = [];

      if (clen < 16)      //* need at least IV and MAC 
      {
         return null;
      }
      memset(nonce, 0, dtls_config.DTLS_CCM_BLOCKSIZE);
      var offst = dtls_kb_iv_size(security, session.role);
      memcpy(nonce, dtls_kb_remote_iv(security, session.role), offst);

      //* read epoch and seq_num from message 
      memcpy(nonce, cleartext, 8, offst, 0);
      offst += 8;
      ctxtoffset += 8;
      clen -= 8;

      //* re-use N to create additional data according to RFC 5246, Section 6.2.3.3:
      //* 
      //* additional_data = seq_num + TLSCompressed.type +
      //*                   TLSCompressed.version + TLSCompressed.length;
 
      var epoch = header.epoch;
      var sequence_number = header.sequence_number;
      
      offst = epoch.length;
      memcpy(A_DATA, epoch, offst); //* epoch
      memcpy(A_DATA, sequence_number, sequence_number.length, offst, 0); //*seq_num 
      offst += sequence_number.length;
      memcpy(A_DATA,  header.content_type, header.content_type.length, offst, 0); //* type  
      offst += header.content_type.length;
      memcpy(A_DATA,  header.version, header.version.length, offst, 0); //* version
      offst += header.version.length;
      var tmp = dtls_config.dtls_int_to_uint16(clen - 8); //* length without nonce_explicit 
      memcpy(A_DATA, tmp, tmp.length, offst, 0);
      offst += tmp.length;

      var rkey = dtls_kb_remote_write_key(security, session.role);
      
      clen = dtls_decrypt(cleartext, ctxtoffset, clen, cleartext, ctxtoffset, nonce,
            rkey, A_DATA);
      if (clen < 0)
      {
         dtls_warn("decryption failed");
      }
      else 
      {
         cleartext = cleartext.slice(ctxtoffset, cleartext.length-8);
         dtls_info("decrypt_verify(): found " + clen +" bytes cleartext, " + cleartext.length);
      }
   }
   return cleartext;
}

function dtls_alert_send_from_err(session, err)
{
   var level;
   var desc;

   if (err < -256 && err > -(3 * 256)) 
   {
      level = Math.floor(((-err) & 0xff00) / 256);
      desc = (-err) & 0xff;
      session.state = dtls_config.DTLS_STATE_CLOSING;
      return dtls_send_alert(session, level, desc);
   } 

   else if (err == -1) 
   {
      session.state = dtls_config.DTLS_STATE_CLOSING;
      return dtls_send_alert(session, dtls_config.DTLS_ALERT_LEVEL_FATAL, dtls_config.DTLS_ALERT_INTERNAL_ERROR);
   }
   return -1;
}

function dtls_send_alert(session, level, description)
{
   dtls_debug("dtls_send_alert() enter");
   var msg = [level, description];

   dtls_send(session, dtls_config.DTLS_CT_ALERT, msg);
   dtls_debug("dtls_send_alert() exit");
   return 0;
}

function dtls_destroy_peer(session, n)
{
   if (session)
   {
      dtls_send_alert(session, dtls_config.DTLS_ALERT_LEVEL_FATAL, dtls_config.DTLS_ALERT_CLOSE_NOTIFY);
	  session.reset();
   }
}

function handle_ccs(session, record_header, data)
{
   dtls_debug("handle_ccs () enter");
   var data_length = data.length;
   var err;
   
   if (!session || session.state != dtls_config.DTLS_STATE_WAIT_CHANGECIPHERSPEC) 
   {
      dtls_warn("expected ChangeCipherSpec during handshake");
      return 0;
   }
   
   var handshake = session.handshake_params;

   if (data_length < 1 || data[0] != 1)
   {
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }

   if (session.role == dtls_config.DTLS_SERVER) 
   {
      err = calculate_key_block(session);
      if (err < 0) 
      {
         return err;
      }
   }
     
   session.state = dtls_config.DTLS_STATE_WAIT_FINISHED;
   dtls_debug("handle_ccs () exit");

   return 0;
}

function handle_alert(session, record_header, data)
{
   dtls_debug("handle_alert () enter");
   var data_length = data.length;
   var free_peer = 0;    //* indicates whether to free peer 

   if (data_length < 2)
   {
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }

   dtls_info("** Alert: level " + data[0] + " description " + data[1]);

   if (data[0] == dtls_config.DTLS_ALERT_LEVEL_FATAL 
         || data[1] == dtls_config.DTLS_ALERT_CLOSE_NOTIFY) 
   {
	  dtls_config.dtls_alert("DTLS_ALERT_CLOSE_NOTIFY, invalidate peer ");
      free_peer = 1;
   }

   if (free_peer) 
   {
      dtls_destroy_peer(session, 1);  
   }

   dtls_debug("handle_alert () exit");
   return free_peer;
}

function check_server_key_exchange_psk(session, data)
{
   dtls_debug("check_server_key_exchange_psk () enter");
   dtls_crit("check_server_key_exchange_psk() not implemented");
   dtls_debug("check_server_key_exchange_psk () exit");
}


function check_certificate_request(session, sdata)
{
   var data_length = sdata.length;
   
   dtls_debug("check_certificate_request () enter");
   var idx = 0;
   var i;
   var auth_alg;
   var sig_alg;
   var hash_alg;
   
   var timeStart     = Math.floor(Date.now());
   
   update_hs_hash(session, sdata);

   idx += dtls_config.DTLS_HS_LENGTH;
   data = sdata.slice(idx, idx+1);

   if (data_length < dtls_config.DTLS_HS_LENGTH + 5) 
   {
      dtls_alert("the packet length does not match the expected");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }

   i = dtls_uint8_to_int(data);
   idx += data.length;

   if (i + 1 > data_length) 
   {
      dtls_alert("the cerfificate types are too long");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }

   auth_alg = 0;
   for (; i > 0 ; i -= 1) 
   {
      data = sdata.slice(idx, idx+1);
      if (dtls_uint8_to_int(data) == dtls_config.TLS_CLIENT_CERTIFICATE_TYPE_ECDSA_SIGN
              && auth_alg == 0)
      {
         auth_alg = dtls_uint8_to_int(data);
      }
      idx += data.length;
   }

   if (auth_alg != dtls_config.TLS_CLIENT_CERTIFICATE_TYPE_ECDSA_SIGN) 
   {
      dtls_alert("the request authentication algorithm is not supproted");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }

   data = sdata.slice(idx, idx+2);
   i = dtls_uint16_to_int(data);
   idx += data.length;

   if (i + 1 > data_length) 
   {
      dtls_alert("the signature and hash algorithm list is too long");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }

   hash_alg = 0;
   sig_alg = 0;

   for (; i > 0; i -= 2) 
   {
      var current_hash_alg;
      var current_sig_alg;

      data = sdata.slice(idx, idx+1);
      current_hash_alg = dtls_uint8_to_int(data);
      idx += data.length;
      data = sdata.slice(idx, idx+1);
      current_sig_alg = dtls_uint8_to_int(data);
      idx += data.length;

      if (current_hash_alg == dtls_config.TLS_EXT_SIG_HASH_ALGO_SHA256 && 
            hash_alg == 0 && 
            current_sig_alg == dtls_config.TLS_EXT_SIG_HASH_ALGO_ECDSA && 
            sig_alg == 0) 
      {
         hash_alg = current_hash_alg;
         sig_alg = current_sig_alg;
      }
   }

   if (hash_alg != dtls_config.TLS_EXT_SIG_HASH_ALGO_SHA256 ||
       sig_alg != dtls_config.TLS_EXT_SIG_HASH_ALGO_ECDSA) 
   {
      dtls_alert("no supported hash and signature algorithem");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }

   //* common names are ignored 

   session.handshake_params.do_client_auth = 1;
   var timeSinceStart = Math.floor(Date.now()) - timeStart;
   dtls_debug("check_certificate_request time (msec):"+timeSinceStart);
   dtls_debug("check_certificate_request () exit");
   return 0;
}

function equals(a, b, len, aoff, boff)
{
   var retV = true;
   for (var i = 0; i < len; i++)
   {
      if (a[i+aoff] != b[i+boff])
      {
         retV = false;
         break;
      }
   }
   
   return retV;
}

function check_finished(session, data)
{
   dtls_debug("check_finished () enter");

   var data_length = data.length;
   var label;
   var buf = [];

   if (data_length < dtls_config.DTLS_HS_LENGTH + dtls_config.DTLS_FIN_LENGTH)
   {
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }

   var statebuf = {};
   var verify_data = [];

   copy_hs_hash(session.handshake_params.hs_state.hs_hash, statebuf);
   dtls_hash_finalize(buf, session.handshake_params.hs_state.hs_hash);
   copy_hs_hash(statebuf, session.handshake_params.hs_state.hs_hash);

   if (session.role == dtls_config.DTLS_CLIENT) 
   {
      label = dtls_config.prf_label_server;
   } 
   else 
   { 
      label = dtls_config.prf_label_client;
   }

   verify_data = dtls_prf(session.handshake_params.tmp.master_secret,
      label, 
      dtls_config.prf_label_finished,
      buf,
      dtls_config.DTLS_FIN_LENGTH);

   dtls_debug("check_finished () exit");
   //* compare verify data and create DTLS alert code when they differ 
   return equals(data, verify_data, verify_data.length, dtls_config.DTLS_HS_LENGTH, 0)
      ? 0 : dtls_alert_create(dtls_config.DTLS_ALERT_LEVEL_FATAL, dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
}


function check_stack()
{
}
 //DTLS_ECC_FEATURE begin
function check_client_keyexchange(handshake, data, length) 
{
   var idx = 0;
   var sdata;

   if (is_tls_ecdhe_ecdsa_with_aes_128_ccm_8(handshake.cipher)) 
   {     
      if (length < dtls_config.DTLS_HS_LENGTH + dtls_config.DTLS_CKXEC_LENGTH) 
      {
         dtls_warn("The client key exchange is too short");
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
      }
      idx += dtls_config.DTLS_HS_LENGTH;
      sdata = data.slice(idx, idx+1);

      if (dtls_uint8_to_int(sdata) != 1 + 2 * dtls_config.DTLS_EC_KEY_SIZE) 
      {
         dtls_warn("expected 65 bytes long public point");
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
      }
      idx += sdata.length;
      sdata = data.slice(idx, idx+1);
      
      if (dtls_uint8_to_int(sdata) != 4) 
      {
         dtls_warn("expected uncompressed public point");
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
      }
      idx += sdata.length;
      sdata = data.slice(idx, idx+dtls_config.DTLS_EC_KEY_SIZE);
      handshake.keyx.ecdsa.other_eph_pub_x = [];
      
      memcpy(handshake.keyx.ecdsa.other_eph_pub_x, sdata, sdata.length);
      idx += sdata.length;
      sdata = data.slice(idx, idx+dtls_config.DTLS_EC_KEY_SIZE);
      handshake.keyx.ecdsa.other_eph_pub_y = [];
      
      memcpy(handshake.keyx.ecdsa.other_eph_pub_y, sdata, sdata.length);
      idx += sdata.length;
      sdata = data.slice(idx, data.length);
   }
   else if (is_tls_psk_with_aes_128_ccm_8(handshake.cipher)) 
   {
      var id_length;

      if (length < dtls_config.DTLS_HS_LENGTH + dtls_config.DTLS_CKXPSK_LENGTH_MIN) 
      {
         dtls_info("The client key exchange is too short");
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
      }
      idx += dtls_config.DTLS_HS_LENGTH;
      sdata = data.slice(idx, idx+2);

      id_length = dtls_uint16_to_int(sdata);
      idx += sdata.length;
      sdata = data.slice(idx, idx + id_length);
      
      if (dtls_config.DTLS_HS_LENGTH + dtls_config.DTLS_CKXPSK_LENGTH_MIN + id_length != length) 
      {
         dtls_info("The identity has a wrong length");
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
      }

      if (id_length > dtls_config.DTLS_PSK_MAX_CLIENT_IDENTITY_LEN) 
      {
         dtls_warn("please use a smaller client identity");
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_INTERNAL_ERROR);
      }

      handshake.keyx.psk.id_length = id_length;
      memcpy(handshake.keyx.psk.identity, sdata, id_length);
   }

   return 0;
}

function dtls_check_ecdsa_signature_elem(sdata, data_length, result_r, result_s)
{
   var i;
   var idx = 0;
   var data = sdata.slice(idx, idx+1);
   
   if (dtls_uint8_to_int(data) != dtls_config.TLS_EXT_SIG_HASH_ALGO_SHA256) 
   {
      dtls_warn("only sha256 is supported in certificate verify");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+1);

   if (dtls_uint8_to_int(data) != dtls_config.TLS_EXT_SIG_HASH_ALGO_ECDSA) 
   {
      dtls_alert("only ecdsa signature is supported in client verify");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+2);

   if (data_length < dtls_uint16_to_int(data)) 
   {
      dtls_alert("signature length wrong");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+1);

   if (dtls_uint8_to_int(data) != 0x30) 
   {
      dtls_alert("wrong ASN.1 struct, expected SEQUENCE");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+1);;

   if (data_length < dtls_uint8_to_int(data)) 
   {
      dtls_alert("signature length wrong");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }
   idx += data.length;
   data_length -= data.length; 
   data = sdata.slice(idx, idx+1);

   if (dtls_uint8_to_int(data) != 0x02) 
   {
      dtls_alert("wrong ASN.1 struct, expected Integer");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+1);

   i = dtls_uint8_to_int(data);
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+i);

   //* Sometimes these values have a leeding 0 byte 
   memcpy(result_r, data.slice(i - dtls_config.DTLS_EC_KEY_SIZE, i), dtls_config.DTLS_EC_KEY_SIZE);

   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+1);

   if (dtls_uint8_to_int(data) != 0x02) 
   {
      dtls_alert("wrong ASN.1 struct, expected Integer");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+1);

   i = dtls_uint8_to_int(data);
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+i);

   //* Sometimes these values have a leeding 0 byte 
   memcpy(result_s, data.slice(i - dtls_config.DTLS_EC_KEY_SIZE, i), dtls_config.DTLS_EC_KEY_SIZE);
   
   idx += data.length;
   data_length -= data.length;

   return idx;
}

function check_client_certificate_verify(session, sdata, data_length)
{
   var config = session.handshake_params;
   var ret;
   var result_r;
   var result_s;
   var hs_hash = {};
   var sha256hash = [];
   var idx = dtls_config.DTLS_HS_LENGTH;
   var data = sdata.slice(idx, sdata.length);

   if (data_length < dtls_config.DTLS_HS_LENGTH + dtls_config.DTLS_CV_LENGTH) 
   {
      dtls_alert("the packet length does not match the expected");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }

   ret = dtls_check_ecdsa_signature_elem(data, data_length, result_r, result_s);
   if (ret < 0) 
   {
      return ret;
   }
   idx += ret;
   data = sdata.slice(idx, sdata.length);
   data_length -= ret;

   copy_hs_hash(session.handshake_params.hs_state.hs_hash, hs_hash);

   dtls_hash_finalize(sha256hash, hs_hash);

   ret = dtls_ecdsa_verify_sig_hash(config.keyx.ecdsa.other_pub_x, config.keyx.ecdsa.other_pub_y,
             config.keyx.ecdsa.other_pub_x.length, sha256hash, sha256hash.length,
             result_r, result_s);

   if (ret < 0) 
   {
      dtls_alert("wrong signature err: ", ret);
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }
   return 0;
}
 //DTLS_ECC_FEATUREend
function dtls_send_hello_request(session)
{
}

function DTLS_HANDSHAKE_HEADER(data)
{
   var hdr = {};
   hdr.msg_type = data[0]; /**< Type of handshake message  (one of DTLS_HT_) */
   hdr.length = data.slice(1,1+3);  /**< length of this message */
   hdr.message_seq = data.slice(4,4+2);  /**< Message sequence number */
   hdr.fragment_offset = data.slice(6,6+3); /**< Fragment offset. */
   hdr.fragment_length = data.slice(9,9+3); /**< Fragment length. */
   return hdr;
}

function check_server_hello_verify_request(session, data)
{
   var hv = {};
   var res;

   if (data.length < dtls_config.DTLS_HS_LENGTH + dtls_config.DTLS_HV_LENGTH)
   {
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }

   hv = 
   {
      version :      [data[dtls_config.DTLS_HS_LENGTH], data[dtls_config.DTLS_HS_LENGTH+1]],     //**< Server version 
      cookie_length: data[dtls_config.DTLS_HS_LENGTH+2],  /**< Length of the included cookie */
      cookie:        []    /**< up to 32 bytes making up the cookie */
   }
   
   if (hv.cookie_length)
   {
      hv.cookie = data.splice(dtls_config.DTLS_HS_LENGTH + 3, dtls_config.DTLS_HS_LENGTH + 3 + hv.cookie_length);
   }
   res = dtls_send_client_hello(session, hv.cookie, hv.cookie_length);

   if (res < 0)
   {
      dtls_warn("cannot send ClientHello\n");
   }

   return res;   
}

function SKIP_VAR_FIELD(data, m, n)
{
   data.splice(0, m+n);
}

function known_cipher(session, code, is_client)
{
   var psk;
   var ecdsa;
   
   psk = is_psk_supported(session);
   ecdsa = is_ecdsa_supported(session, is_client);
   return (psk && is_tls_psk_with_aes_128_ccm_8(code)) ||
      (ecdsa && is_tls_ecdhe_ecdsa_with_aes_128_ccm_8(code));
}

function dtls_check_tls_extension(session, data, client_hello)
{
   var i, j;
   var ext_elliptic_curve = 0;
   var ext_client_cert_type = 0;
   var ext_server_cert_type = 0;
   var ext_ec_point_formats = 0;
   var handshake = session.handshake_params;
   var error = false;

   if (data.length < 2) 
   { 
      //* no tls extensions specified 
      if (is_tls_ecdhe_ecdsa_with_aes_128_ccm_8(handshake.cipher)) 
      {
         error = true;
      }
      else
      {
         return 0;
      }
   }

   if (!error)
   {
      //* get the length of the tls extension list 
      j = dtls_uint16_to_int(data);
      data.splice(0, 2);
      if (data.length < j)
      {
         error = true;
      }
   }
   
   if (!error)
   {
      //* check for TLS extensions needed for this cipher
      while (data.length) 
      {
         if (data.length < 2 * 2)
         {
            error = true;
            break;
         }

         //* get the tls extension type 
         i = dtls_uint16_to_int(data);
         data.splice(0, 2);
   
         //* get the length of the tls extension 
         j = dtls_uint16_to_int(data);
         data.splice(0, 2);
   
         if (data.length < j)
         {
            error = true;
            break;
         }

         switch (i) 
         {
         case dtls_config.TLS_EXT_ELLIPTIC_CURVES:
            ext_elliptic_curve = 1;
            if (verify_ext_eliptic_curves(data, j))
            {
               error = true;
            }
            break;
            
         case dtls_config.TLS_EXT_CLIENT_CERTIFICATE_TYPE:
            ext_client_cert_type = 1;
            if (client_hello) 
            {
               if (verify_ext_cert_type(data, j))
               {
                  error = true;
               }
            } 
            else 
            {
               if (dtls_uint8_to_int(data) != dtls_config.TLS_CERT_TYPE_RAW_PUBLIC_KEY)
               {
                  error = true;
               }
            }
            break;
            
         case dtls_config.TLS_EXT_SERVER_CERTIFICATE_TYPE:
            ext_server_cert_type = 1;
            if (client_hello) 
            {
               if (verify_ext_cert_type(data, j))
               {
                  error = true;
               }
            } 
            else 
            {
               if (dtls_uint8_to_int(data) != dtls_config.TLS_CERT_TYPE_RAW_PUBLIC_KEY)
               {
                  error = true;
               }
            }
            break;
            
         case dtls_config.TLS_EXT_EC_POINT_FORMATS:
            ext_ec_point_formats = 1;
            if (verify_ext_ec_point_formats(data, j))
            {
               error = true;
            }
            break;
            
         case dtls_config.TLS_EXT_ENCRYPT_THEN_MAC:
            //* As only AEAD cipher suites are currently available, this
            //* extension can be skipped. 
            dtls_info("skipped encrypt-then-mac extension");
            break;
            
         default:
            dtls_warn("unsupported tls extension: " + i);
            break;
         }
         
         if (error)
         {
            break;
         }
         data.splice(0, j);
      }
   }
      
   if (!error)
   {
      if (is_tls_ecdhe_ecdsa_with_aes_128_ccm_8(handshake.cipher) && client_hello) 
      {
         if (!ext_elliptic_curve || !ext_client_cert_type || !ext_server_cert_type
            || !ext_ec_point_formats) 
         {
            dtls_warn("not all required tls extensions found in client hello");
            error = true;
         }
      } 
      else if (is_tls_ecdhe_ecdsa_with_aes_128_ccm_8(handshake.cipher) && !client_hello) 
      {
         if (!ext_client_cert_type || !ext_server_cert_type) 
         {
            dtls_warn("not all required tls extensions found in server hello");
            error = true;
         }
      }
   }
   
   if (!error)
   {
      return 0;
   }
   else
   {
      if (client_hello && session.state == dtls_config.DTLS_STATE_CONNECTED) 
      {
         return dtls_alert_create(dtls_config.DTLS_ALERT_LEVEL_WARNING, dtls_config.DTLS_ALERT_NO_RENEGOTIATION);
      } 
      else 
      {
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
      }
   }
}

function check_server_hello(session, data)
{
   var handshake = session.handshake_params;

   dtls_debug("check_server_hello() enter");
   //* This function is called when we expect a ServerHello (i.e. we
   //* have sent a ClientHello).  We might instead receive a HelloVerify
   //* request containing a cookie. If so, we must repeat the
   //* ClientHello with the given Cookie.

   if (data.length < dtls_config.DTLS_HS_LENGTH + dtls_config.DTLS_HS_LENGTH)
   {
      dtls_warn("server hello: bad data length");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }

   update_hs_hash(session, data);

   //* Get the server's random data and store selected cipher suite
   //* and compression method (like dtls_update_parameters().
   //* Then calculate master secret and wait for ServerHelloDone. When received,
   //* send ClientKeyExchange (?) and ChangeCipherSpec + ClientFinished. 
 
   //* check server version 
   data.splice(0, dtls_config.DTLS_HS_LENGTH);
 
   if (dtls_uint16_to_int(data) != dtls_config.DTLS_VERSION) 
   {
      dtls_config.dtls_alert("unknown DTLS version");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_PROTOCOL_VERSION);
   }
   
   data.splice(0, 2);        //* skip version field 

   //* store server random data 
   handshake.tmp.random.server = [];
   memcpy(handshake.tmp.random.server, data, dtls_config.DTLS_RANDOM_LENGTH);
   //* skip server random 
   data.splice(0, dtls_config.DTLS_RANDOM_LENGTH);

   SKIP_VAR_FIELD(data, dtls_config.dtls_uint8_to_int(data), 1); //* skip session id 
 
   //* Check cipher suite. As we offer all we have, it is sufficient
   //* to check if the cipher suite selected by the server is in our
   //* list of known cipher suites. Subsets are not supported. 
   handshake.cipher = dtls_uint16_to_int(data);
   if (!known_cipher(session, handshake.cipher, 1)) 
   {
	   dtls_config.dtls_alert("unsupported cipher " + data[0] + "," + data[1]);
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_INSUFFICIENT_SECURITY);
   }
   data.splice(0, 2);

   //* Check if NULL compression was selected. We do not know any other. 
   if (dtls_uint8_to_int(data) != dtls_config.TLS_COMPRESSION_NULL) 
   {
	   dtls_config.dtls_alert("unsupported compression method " + data[0]);
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_INSUFFICIENT_SECURITY);
   }
   data.splice(0, 1);
   
   var retv = dtls_check_tls_extension(session, data, 0)

   dtls_debug("check_server_hello() exit");
   return retv;
}

function dtls_send_client_key_exchange(session)
{
   dtls_debug("dtls_send_client_key_exchange() enter");
   var handshake = session.handshake_params;
   var buf = [];

   switch (handshake.cipher) 
   {
      case dtls_config.TLS_PSK_WITH_AES_128_CCM_8: 
         var handshake = session.handshake_params;
         
         if (session.h && session.h.get_psk_info)
         {
            buf =  session.h.get_psk_info(session, dtls_config.DTLS_PSK_IDENTITY, handshake.keyx.psk.identity);
         }
         
         if (!buf) 
         {
            dtls_crit("no psk identity set in kx");
            return -1;
         }
      
         buf.splice(0,0,0,0);  //Insert two bytes at the start
         if (buf.length > dtls_config.DTLS_CKXEC_LENGTH) 
         {
            dtls_warn("the psk identity is too long");
            handshake.keyx.psk = [];
            return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_INTERNAL_ERROR);
         }
         memcpy(handshake.keyx.psk.identity, buf, buf.length - 2, 0, 2);
    
         var xt = dtls_config.dtls_int_to_uint16(handshake.keyx.psk.identity.length);
         buf[0] = xt[0];
         buf[1] = xt[1];
 
         //memcpy(buf, handshake.keyx.psk.identity, handshake.keyx.psk.identity.length, 2, 0);   
         break;
  //DTLS_ECC_FEATURE ebgin        
      case dtls_config.TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8: 
         var ephemeral_pub_x = [];
         var ephemeral_pub_y = [];
         var tbuf = buf.concat(dtls_int_to_uint8(1 + 2 * dtls_config.DTLS_EC_KEY_SIZE));
    
         //* This should be an uncompressed point, but I do not have access to the spec. 
         buf = tbuf.concat(dtls_int_to_uint8(4));
         dtls_ecdsa_generate_key(session.handshake_params.keyx.ecdsa.own_eph_priv,
                ephemeral_pub_x, ephemeral_pub_y,
                dtls_config.DTLS_EC_KEY_SIZE);
         
         tbuf = buf.concat(ephemeral_pub_x);
         buf = tbuf.concat(ephemeral_pub_y);
         break;
 //DTLS_ECC_FEATURE end         
   default:
         dtls_crit("cipher not supported");
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_INTERNAL_ERROR);
         break;
   }
   
   var retv = dtls_send_handshake_msg(session, dtls_config.DTLS_HT_CLIENT_KEY_EXCHANGE, buf);
   dtls_debug("dtls_send_client_key_exchange() exit");
   return retv;
}

function dtls_security_params_next(session)
{
    session.security_params_next.epoch = session.security_params.epoch + 1;
    return session.security_params_next;
}

function dtls_psk_pre_master_secret(key)
{
   var result;

   result = dtls_config.dtls_int_to_uint16(key.length);
   memset(result, 0, key.length, result.length);
   result.splice(result.length, 0, result[0], result[1]);
   result = result.concat(key);

   return result;
}

function dtls_kb_mac_secret_size(Param, Role)
{
   return dtls_config.DTLS_MAC_KEY_LENGTH;
}

function dtls_kb_key_size(Param, Role)
{
   return dtls_config.DTLS_KEY_LENGTH;
}

function dtls_kb_iv_size(Param, Role)
{
   return dtls_config.DTLS_IV_LENGTH;
}

function dtls_kb_size(Param, Role)
{

   return (2 * 
         (dtls_kb_mac_secret_size(Param, Role) +  
               dtls_kb_key_size(Param, Role) + 
               dtls_kb_iv_size(Param, Role)));
}

function calculate_key_block(session)
{     
   var handshake = session.handshake_params;
   var pre_master_secret = [];
   var security = dtls_security_params_next(session);
   var master_secret = [];
   
   if (!security) 
   {
      dtls_crit("dtls_security_params_next() failed");     
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_INTERNAL_ERROR);
   }

   switch (handshake.cipher) 
   {
   case dtls_config.TLS_PSK_WITH_AES_128_CCM_8: 
      var psk = null;
      
      if (session.h && session.h.get_psk_info)
      {
         psk = session.h.get_psk_info(session, dtls_config.DTLS_PSK_KEY,  handshake.keyx.psk.identity);
      }
      if (!psk) 
      {
         dtls_crit("no psk key for session available");
         return -1;
      }

      //* Temporarily use the key_block storage space for the pre master secret. 
      pre_master_secret = dtls_psk_pre_master_secret(psk);
      if (!pre_master_secret) 
      {
         dtls_crit("the psk was too long, for the pre master secret");
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_INTERNAL_ERROR);
      }

      break;
 //DTLS_ECC_FEATURE begin
   case dtls_config.TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8:
      var pre_master_len = dtls_ecdh_pre_master_secret(handshake.keyx.ecdsa.own_eph_priv,
                  handshake.keyx.ecdsa.other_eph_pub_x,
                  handshake.keyx.ecdsa.other_eph_pub_y,
                  handshake.keyx.ecdsa.own_eph_priv.length,
                  pre_master_secret,
                  dtls_config.MAX_KEYBLOCK_LENGTH);
      if (pre_master_len < 0) 
      {
         dtls_crit("the curve was too long, for the pre master secret");
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_INTERNAL_ERROR);
      }
      break;

   //DTLS_ECC_FEATURE end    
   default:
      dtls_crit("calculate_key_block: unknown cipher");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_INTERNAL_ERROR);
   }
   
   master_secret = dtls_prf(pre_master_secret, 
      dtls_config.prf_label_master,
      handshake.tmp.random.client,
      handshake.tmp.random.server,
      dtls_config.DTLS_MASTER_SECRET_LENGTH);
   
   //* create key_block from master_secret
   //key_block = PRF(master_secret, "key expansion" + tmp.random.server + tmp.random.client) 

   security.key_block = dtls_prf(master_secret,
      dtls_config.prf_label_key,
      handshake.tmp.random.server,
      handshake.tmp.random.client,
      dtls_kb_size(security, session.role));

   memcpy(handshake.tmp.master_secret, master_secret, master_secret.length);

   security.cipher = handshake.cipher;
   security.compression = handshake.compression;
   security.rseq = 0;
   return 0;
}

function dtls_send_ccs(session)
{
   var buf = [1];
   return dtls_send(session, dtls_config.DTLS_CT_CHANGE_CIPHER_SPEC, buf);
}

function dtls_security_params_switch(session)
{
   session.security_index = (session.security_index + 1) % 2;
   session.security_params_next = session.security_params_array[(session.security_index + 1) % 2];
   session.security_params = session.security_params_array[session.security_index];
}

function dtls_security_params_epoch(session, epoch)
{
   if (session.security_params && session.security_params.epoch == epoch) 
   {
      return session.security_params;
   } 
   else if (session.security_params_next && session.security_params_next.epoch == epoch) 
   {
      return session.security_params_next;
   } 
   else 
   {
      return null;
   }
}

function copy_hs_hash(p_hs_hash, hs_hash) 
{
   hs_hash.state = p_hs_hash.state.slice(0,p_hs_hash.state.length);
   hs_hash.buffer = p_hs_hash.buffer.slice(0,p_hs_hash.buffer.length);;
   hs_hash.bitcount = p_hs_hash.bitcount;
 }

function dtls_send_finished(session, label)
{
   dtls_debug('dtls_send_finished() enter');
   var hash = [];
   var hs_hash = {};
   var buf;

   copy_hs_hash(session.handshake_params.hs_state.hs_hash, hs_hash);
    dtls_hash_finalize(hash, hs_hash);

   buf = dtls_prf(session.handshake_params.tmp.master_secret,
      label, 
      dtls_config.prf_label_finished,
      hash, 
      dtls_config.DTLS_FIN_LENGTH);

   var retv = dtls_send_handshake_msg(session, dtls_config.DTLS_HT_FINISHED, buf);
   dtls_debug('dtls_send_finished() exit');
   return retv;
}

function check_server_hellodone(session, data)
{
   var res = 1;
   var ecdsa_key = {};
   var handshake = session.handshake_params;
   var delay = 1;
   
   dtls_debug("check_server_hellodone() enter");
   //* calculate master key, send CCS 
   update_hs_hash(session, data);
 //DTLS_ECC_FEATURE begin   
   if (handshake.do_client_auth) 
   {
      res = session.h.get_ecdsa_key(session, ecdsa_key);
      if (res < 0) 
      {
         dtls_crit("no ecdsa certificate to send in certificate");
         return res;
      }
   
      res = dtls_send_certificate_ecdsa(session, ecdsa_key);
   
      if (res < 0) 
      {
         dtls_warn("dtls_server_hello: cannot prepare Certificate record");
         return res;
      }
      
      delay += 3000;
   }
 //DTLS_ECC_FEATURE end
   //* send ClientKeyExchange 
   setTimeout(function()
   {
      if (res >= 0)
      {
         res = dtls_send_client_key_exchange(session);
      
         if (res < 0) 
         {
            dtls_info("cannot send KeyExchange message");
         }
      }
   }, delay);
   
   delay += 3000;
   setTimeout(function()
   {
     //DTLS_ECC_FEATURE begin 
      if (res >= 0)
      {
         if (handshake.do_client_auth) 
         {
            res = dtls_send_certificate_verify_ecdh(session, ecdsa_key);
      
            if (res < 0) 
            {
               dtls_warn("dtls_server_hello: cannot prepare Certificate record");
            }
         }
      }
   }, delay);
   
   delay += 6000;
 //DTLS_ECC_FEATURE end
   setTimeout(function()
   {
      if (res >= 0)
      {
         res = calculate_key_block(session);
      }
      
      if (res >= 0) 
      {
         res = dtls_send_ccs(session);
         if (res < 0) 
         {
            dtls_info("cannot send CCS message");
         }
         else
         {
            //* and switch cipher suite 
            dtls_security_params_switch(session);
         }
      }
   }, delay);
   
   delay += 3000;
   setTimeout(function()  
   {
      if (res >= 0)
      {
         //* Client Finished 
         dtls_send_finished(session, dtls_config.prf_label_client);
      }
   }, delay);
   
   dtls_debug("check_server_hellodone() exit");
   return 1;
}

function handle_handshake_msg(session, role, state, data)
{
   var err = 0;

   //* This will clear the retransmission buffer if we get an expected
   // * handshake message. We have to make sure that no handshake message
   // * should get expected when we still should retransmit something, when
   // * we do everything accordingly to the DTLS 1.2 standard this should
   // * not be a problem. 

   //* The following switch construct handles the given message with
   // * respect to the current internal state for this peer. In case of
   // * error, it is left with return 0. 

   dtls_debug("handle handshake packet of type: " + dtls_handshake_type_to_name(data[0]) + "(" + data[0] + ")");
   switch (data[0]) 
   {
   /************************************************************************
    * Client states
    ************************************************************************/
   case dtls_config.DTLS_HT_HELLO_VERIFY_REQUEST:
      if (state != dtls_config.DTLS_STATE_CLIENTHELLO) 
      {
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_UNEXPECTED_MESSAGE);
      }

      err = check_server_hello_verify_request(session, data);
      if (err < 0) 
      {
         dtls_warn("error in check_server_hello_verify_request err: " + err);
         return err;
      }
      
      break;
     
   case dtls_config.DTLS_HT_SERVER_HELLO:
      if (state != dtls_config.DTLS_STATE_CLIENTHELLO) 
      {
         dtls_warn("SERVER HELLO received unexpectedly");
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_UNEXPECTED_MESSAGE);
      }

      err = check_server_hello(session, data);
      if (err < 0) 
      {
         dtls_warn("error in check_server_hello err: " + err);
         return err;
      }
     
      if (is_tls_ecdhe_ecdsa_with_aes_128_ccm_8(session.handshake_params.cipher))
      {
         session.state = dtls_config.DTLS_STATE_WAIT_SERVERCERTIFICATE;
      }
      else
      {
         session.state = dtls_config.DTLS_STATE_WAIT_SERVERHELLODONE;
      }
      break;
      //DTLS_ECC_FEATURE begin
   case dtls_config.DTLS_HT_CERTIFICATE:
      if ((role == dtls_config.DTLS_CLIENT && state != dtls_config.DTLS_STATE_WAIT_SERVERCERTIFICATE) ||
         (role == dtls_config.DTLS_SERVER && state != dtls_config.DTLS_STATE_WAIT_CLIENTCERTIFICATE)) 
      {
         dtls_warn("Unexpected server certificate message");
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_UNEXPECTED_MESSAGE);
      }
      err = check_server_certificate(session, data);
      if (err < 0) 
      {
         dtls_warn("error in check_server_certificate err: ", err);
         return err;
      }
      if (role == dtls_config.DTLS_CLIENT) 
      {
         session.state = dtls_config.DTLS_STATE_WAIT_SERVERKEYEXCHANGE;
      } 
      else if (role == dtls_config.DTLS_SERVER)
      {
         session.state = dtls_config.DTLS_STATE_WAIT_CLIENTKEYEXCHANGE;
      }
      //* update_hs_hash(peer, data, data_length); 
      break; 
      //DTLS_ECC_FEATURE end
   case dtls_config.DTLS_HT_SERVER_KEY_EXCHANGE:
 //DTLS_ECC_FEATURE begin
      if (is_tls_ecdhe_ecdsa_with_aes_128_ccm_8(session.handshake_params.cipher)) 
      {
         if (state != dtls_config.DTLS_STATE_WAIT_SERVERKEYEXCHANGE) 
         {
            return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_UNEXPECTED_MESSAGE);
         }
         err = check_server_key_exchange_ecdsa(session, data, data.length);
      }
 //DTLS_ECC_FEATURE end
      else if (is_tls_psk_with_aes_128_ccm_8(session.handshake_params.cipher)) 
      {
         if (state != dtls_config.DTLS_STATE_WAIT_SERVERHELLODONE) 
         {
            return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_UNEXPECTED_MESSAGE);
         }
         err = check_server_key_exchange_psk(session, data);
      }


      if (err < 0) 
      {
         dtls_warn("error in check_server_key_exchange err: " + err);
         return err;
      }
      session.state = dtls_config.DTLS_STATE_WAIT_SERVERHELLODONE;
      break;

   case dtls_config.DTLS_HT_SERVER_HELLO_DONE:
      if (state != dtls_config.DTLS_STATE_WAIT_SERVERHELLODONE) 
      {
         dtls_info("state != dtls_config.DTLS_STATE_WAIT_SERVERHELLODONE");
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_UNEXPECTED_MESSAGE);
      }

      err = check_server_hellodone(session, data);
      if (err < 0) 
      {
         dtls_warn("error in check_server_hellodone err: " + err);
         return err;
      }
      session.state = dtls_config.DTLS_STATE_WAIT_CHANGECIPHERSPEC;
      break;

   case dtls_config.DTLS_HT_CERTIFICATE_REQUEST:
      if (state != dtls_config.DTLS_STATE_WAIT_SERVERHELLODONE) 
      {
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_UNEXPECTED_MESSAGE);
      }
      err = check_certificate_request(session, data);
      if (err < 0) 
      {
         dtls_warn("error in check_certificate_request err: " + err);
         return err;
      }
      break;

   case dtls_config.DTLS_HT_FINISHED:
      //* expect a Finished message from server 
      if (state != dtls_config.DTLS_STATE_WAIT_FINISHED) 
      {
         return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_UNEXPECTED_MESSAGE);
      }

      err = check_finished(session, data);
      if (err < 0) 
      {
         dtls_warn("error in check_finished err: " + err);
         return err;
      }
      if (role == dtls_config.DTLS_SERVER) 
      {
         //* send ServerFinished 
         update_hs_hash(session, data);

         //* send change cipher spec message and switch to new configuration 
         err = dtls_send_ccs(session);
         if (err < 0) 
         {
            dtls_warn("cannot send CCS message");
            return err;
         }
         
         dtls_security_params_switch(session);

         err = dtls_send_finished(session, dtls_config.prf_label_server);
         if (err < 0) 
         {
            dtls_warn("sending server Finished failed");
            return err;
         }
      }
    
      dtls_info("Handshake complete\n");
      check_stack();
      session.state = dtls_config.DTLS_STATE_CONNECTED;
      dtls_info("DTLS connected"); 
      
      //* return here to not increase the message receive counter 
      return err;

   default:
     dtls_crit("unhandled message " + data[0]);
     return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_UNEXPECTED_MESSAGE);
   }

   if (session && session.handshake_params && err >= 0) 
   {
      session.handshake_params.hs_state.mseq_r++;
   }
   else
   {
      dtls_crit("mseq_r NOT inc due to error: " + session.handshake_params.hs_state.mseq_r + ", err: " + err);
   }

   return err;
}

function handle_handshake(session, role, state, data)
{
   dtls_debug("Handshake message received:" + data[0] + ", rlen = " + data.length);
   
   var hs_header;
   var res;

   if (data.length < dtls_config.DTLS_HS_LENGTH) 
   {
      dtls_warn("handshake message too short");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }
   hs_header = DTLS_HANDSHAKE_HEADER(data);

   dtls_debug("received handshake packet of type: " + dtls_handshake_type_to_name(hs_header.msg_type) + " (" + hs_header.msg_type + ")");

   if (!session.handshake_params) 
   {
      // This is the initial ClientHello 
      // This is a ClientHello or Hello Request send when doing TLS renegotiation 
      if (hs_header.msg_type == dtls_config.DTLS_HT_CLIENT_HELLO ||
         hs_header.msg_type == dtls_config.DTLS_HT_HELLO_REQUEST) 
      {
         return handle_handshake_msg(session, role, state, data);
      } 
      else 
      {
         dtls_warn("ignore unexpected handshake message");
         return 0;
      }
   }

   if (dtls_config.dtls_uint16_to_int(hs_header.message_seq) < session.handshake_params.hs_state.mseq_r) 
   {
      dtls_warn("The message sequence number is too small, expected " + 
            session.handshake_params.hs_state.mseq_r + 
            ", got: " 
            + dtls_config.dtls_uint16_to_int(hs_header.message_seq));
      return 0;
   } 
   else if (dtls_config.dtls_uint16_to_int(hs_header.message_seq) > session.handshake_params.hs_state.mseq_r) 
   {
      dtls_info("The message sequence number is too large, expect " + 
            session.handshake_params.hs_state.mseq_r + 
            ", got: " 
            + dtls_config.dtls_uint16_to_int(hs_header.message_seq));
      // A packet in between is missing, buffer this packet. 
      var i = 0;
      while (i < session.handshake_params.reorder_queue.length) 
      {
         var node = session.handshake_params.reorder_queue[i];
         var node_header = DTLS_HANDSHAKE_HEADER(node.data);
         if (dtls_config.dtls_uint16_to_int(node_header.message_seq) == dtls_config.dtls_uint16_to_int(hs_header.message_seq)) 
         {
            dtls_warn("a packet with this sequence number is already stored");
            return 0;
         }
         i++;
      }

      var n = {};
      n.session = session;
      n.data = [];
      memcpy(n.data, data, data.length);
      session.handshake_params.reorder_queue.push(n);

      dtls_info("Added packet for reordering");
      return 0;
   } 
   else if (dtls_config.dtls_uint16_to_int(hs_header.message_seq) == session.handshake_params.hs_state.mseq_r) 
   {
      /* Found the expected packet, use this and all the buffered packet */
      var next = 1;

      res = handle_handshake_msg(session, role, state, data);
      if (res < 0)
      {
         return res;
      }

      /* We do not know in which order the packet are in the list just search the list for every packet. */
      while (next && session.handshake_params) 
      {
         next = 0;
         var i = 0;
         
         while (i < session.handshake_params.reorder_queue.length) 
         {
            var node = session.handshake_params.reorder_queue[i];
            var node_header = DTLS_HANDSHAKE_HEADER(node.data);

            if (dtls_config.dtls_uint16_to_int(node_header.message_seq) == session.handshake_params.hs_state.mseq_r) 
            {
               session.handshake_params.reorder_queue.splice(i, 1);
               next = 1;
               res = handle_handshake_msg(session, role, session.state, node.data);
               if (res < 0) 
               {
                  return res;
               }

               break;
            } 
            else 
            {
               i++;
            }
         }
      }
      return res;
    }
    return 0;
}

function dtls_handshake_type_to_name(type)
{
     switch (type) {
     case dtls_config.DTLS_HT_HELLO_REQUEST:
       return "hello_request";
     case dtls_config.DTLS_HT_CLIENT_HELLO:
       return "client_hello";
     case dtls_config.DTLS_HT_SERVER_HELLO:
       return "server_hello";
     case dtls_config.DTLS_HT_HELLO_VERIFY_REQUEST:
       return "hello_verify_request";
     case dtls_config.DTLS_HT_CERTIFICATE:
       return "certificate";
     case dtls_config.DTLS_HT_SERVER_KEY_EXCHANGE:
       return "server_key_exchange";
     case dtls_config.DTLS_HT_CERTIFICATE_REQUEST:
       return "certificate_request";
     case dtls_config.DTLS_HT_SERVER_HELLO_DONE:
       return "server_hello_done";
     case dtls_config.DTLS_HT_CERTIFICATE_VERIFY:
       return "certificate_verify";
     case dtls_config.DTLS_HT_CLIENT_KEY_EXCHANGE:
       return "client_key_exchange";
     case dtls_config.DTLS_HT_FINISHED:
       return "finished";
     default:
       return "unknown";
     }
}

function SHA256_Init(context)
{
   if (!context) 
   {
      return;
   }
   
   context.state = [];
   context.buffer = [];
   context.bitcount = 0;
   
   memcpy(context.state, sha256_initial_hash_value, sha256_initial_hash_value.length);
   memset(context.buffer, 0, dtls_config.SHA256_BLOCK_LENGTH);
}

function dtls_hash_update(ctx, input)
{
   SHA256_Update(ctx, input);
}

function dtls_set_handshake_header(type, session, length, frag_offset, frag_length)
{
   var buf = [];
   
   buf = buf.concat(dtls_int_to_uint8(type));
   buf = buf.concat(dtls_int_to_uint24(length));
   if (session && session.handshake_params) 
   {
      /* and copy the result to buf */
      buf = buf.concat(dtls_int_to_uint16(session.handshake_params.hs_state.mseq_s));

      /* increment handshake message sequence counter by 1 */
      session.handshake_params.hs_state.mseq_s++;
   } 
   else 
   {
      buf = buf.concat([0,0]);  
   }
   buf = buf.concat(dtls_int_to_uint24(frag_offset));
   buf = buf.concat(dtls_int_to_uint24(frag_length));
   
   return buf;
}

function update_hs_hash(session, data)
{
   dtls_hash_update(session.handshake_params.hs_state.hs_hash, data);
}

function dtls_alert_create(level, desc)
{
   return -((level * 256) + desc);
}

function dtls_hash_init(ctx)
{
   SHA256_Init(ctx);
}

function is_psk_supported(session)
{
   if (dtls_config.DTLS_PSK_SUPPORT)
   {
      return session && session.h && session.h.get_psk_info;
   }
   else
   {
      return false;  //DTLS_ECC_FEATURE
   }
}

function is_ecdsa_supported(session, is_client)
{
   if (dtls_config.DTLS_ECC_SUPPORT)
   {
      return session && session.h && ((!is_client && session.h.get_ecdsa_key) || 
         (is_client && session.h.verify_ecdsa_key));
   }
   else
   {
      return false;
   }
}
 //DTLS_ECC_FEATURE begin
function dtls_send_certificate_ecdsa(session, key)
{
   var buf = [];
   var tbuf = [];
   dtls_debug("dtls_send_certificate_ecdsa() enter");
   //* Certificate 
   //*
   buf = tbuf.concat(dtls_int_to_uint24(94));   //* certificates length    
   tbuf = buf.concat(dtls_int_to_uint24(91));   //* length of this certificate   
   buf = tbuf.concat(cert_asn1_header);
   tbuf = buf.concat(key.pub_key_x);
   buf = tbuf.concat(key.pub_key_y);
 
   var retv = dtls_send_handshake_msg(session, dtls_config.DTLS_HT_CERTIFICATE, buf);
   dtls_debug("dtls_send_certificate_ecdsa() exit");
   return retv;
}

function dtls_add_ecdsa_signature_elem(p, point_r, point_s)
{
   var r_key_offset = (1 + 1 + 2 + 1 + 1 + 1 + 1);
   var tbuf = [];
   var i;
   var len_r = dtls_ec_key_from_uint32_asn1(point_r, dtls_config.DTLS_EC_KEY_SIZE, tbuf);
   
   memset(p, 0, r_key_offset);
   for (i = 0; i < tbuf.length; i++)
   {
      p.push(tbuf[i]);
   }
   p.push(0);
   p.push(0);

   tbuf = [];
   var len_s = dtls_ec_key_from_uint32_asn1(point_s, dtls_config.DTLS_EC_KEY_SIZE, tbuf);
   for (i = 0; i < tbuf.length; i++)
   {
      p.push(tbuf[i]);
   }

   var idx = 0;
   //* sha256 
   tbuf = dtls_int_to_uint8(dtls_config.TLS_EXT_SIG_HASH_ALGO_SHA256);
   for (i = 0; i < tbuf.length; i++)
   {
      p[idx + i] = tbuf[i];
   }
   idx += tbuf.length;

   //* ecdsa
   tbuf = dtls_int_to_uint8(dtls_config.TLS_EXT_SIG_HASH_ALGO_ECDSA);
   for (i = 0; i < tbuf.length; i++)
   {
      p[idx + i] = tbuf[i];
   }
   idx += tbuf.length;

   //* length of signature 
   tbuf = dtls_int_to_uint16(len_r + len_s + 2 + 2 + 2);
   for (i = 0; i < tbuf.length; i++)
   {
      p[idx + i] = tbuf[i];
   }
   idx += tbuf.length;

   //* ASN.1 SEQUENCE 
   tbuf = dtls_int_to_uint8(0x30);
   for (i = 0; i < tbuf.length; i++)
   {
      p[idx + i] = tbuf[i];
   }
   idx += tbuf.length;

   tbuf = dtls_int_to_uint8(len_r + len_s + 2 + 2);
   for (i = 0; i < tbuf.length; i++)
   {
      p[idx + i] = tbuf[i];
   }
   idx += tbuf.length;

   //* ASN.1 Integer r 
   tbuf = dtls_int_to_uint8(0x02);
   for (i = 0; i < tbuf.length; i++)
   {
      p[idx + i] = tbuf[i];
   }
   idx += tbuf.length;

   tbuf = dtls_int_to_uint8(len_r);
   for (i = 0; i < tbuf.length; i++)
   {
      p[idx + i] = tbuf[i];
   }
   idx += tbuf.length;

   //* the pint r was added here 
   idx += len_r;

   //* ASN.1 Integer s 
   tbuf = dtls_int_to_uint8(0x02);
   for (i = 0; i < tbuf.length; i++)
   {
      p[idx + i] = tbuf[i];
   }
   idx += tbuf.length;

   tbuf = dtls_int_to_uint8(len_s);
   for (i = 0; i < tbuf.length; i++)
   {
      p[idx + i] = tbuf[i];
   }
   idx += tbuf.length;

   //* the pint s was added here 
   idx += len_s;

   return idx;
}

function dtls_send_server_key_exchange_ecdh(session, key)
{
   //* The ASN.1 Integer representation of an 32 byte unsigned int could be
   //* 33 bytes long add space for that 
   var buf = [];
   var tbuf = [];
   var ttbuf = []; 
   var ephemeral_pub_x = [];
   var ephemeral_pub_y = [];
   var point_r = [];
   var point_s = [];
   var config = session.handshake_params;

   //* ServerKeyExchange 

   //* ECCurveType curve_type: named_curve 
   tbuf = buf.concat(dtls_int_to_uint8(3));
   //* NamedCurve namedcurve: secp256r1 
   buf = tbuf.concat(dtls_int_to_uint16(dtls_config.TLS_EXT_ELLIPTIC_CURVES_SECP256R1));
   tbuf = buf.concat(dtls_int_to_uint8(1 + 2 * dtls_config.DTLS_EC_KEY_SIZE));
   //* This should be an uncompressed point, but I do not have access to the spec. 
   buf = tbuf.concat(dtls_int_to_uint8(4));

   dtls_ecdsa_generate_key(config.keyx.ecdsa.own_eph_priv,
         ephemeral_pub_x, ephemeral_pub_y, dtls_config.DTLS_EC_KEY_SIZE);
   
   tbuf = buf.concat(ephemeral_pub_x);
   buf = tbuf.concat(ephemeral_pub_y);

   //* sign the ephemeral and its paramaters 
   dtls_ecdsa_create_sig(key.priv_key, dtls_config.DTLS_EC_KEY_SIZE,
             config.tmp.random.client, dtls_config.DTLS_RANDOM_LENGTH,
             config.tmp.random.server, dtls_config.DTLS_RANDOM_LENGTH,
             buf, buf.length,
             point_r, point_s);

   dtls_add_ecdsa_signature_elem(ttbuf, point_r, point_s);
   tbuf = buf.concat(ttbuf);
   
   return dtls_send_handshake_msg(session, dtls_config.DTLS_HT_SERVER_KEY_EXCHANGE, tbuf);
}

function dtls_send_server_certificate_request(session)
{
   var buf = [];
   var tbuf = [];

   //* ServerHelloDone 

   //* certificate_types 
   tbuf = buf.concat(dtls_int_to_uint8(1));
   //* ecdsa_sign 
   buf = tbuf.concat(dtls_int_to_uint8(dtls_config.TLS_CLIENT_CERTIFICATE_TYPE_ECDSA_SIGN));   
   //* supported_signature_algorithms 
   tbuf = buf.concat(dtls_int_to_uint16(2));   
   //* sha256 
   buf = tbuf.concat(dtls_int_to_uint8(dtls_config.TLS_EXT_SIG_HASH_ALGO_SHA256));   
   //* ecdsa 
   tbuf = buf.concat(dtls_int_to_uint8(dtls_config.TLS_EXT_SIG_HASH_ALGO_ECDSA));
   //* certificate_authoritiess 
   buf = tbuf.concat(dtls_int_to_uint16(0));

   return dtls_send_handshake_msg(session, dtls_config.DTLS_HT_CERTIFICATE_REQUEST, buf);
}

function dtls_send_server_hello_msgs(session)
{
   var res = dtls_send_server_hello(session);
   if (res < 0) 
   {
      dtls_warn("dtls_server_hello: cannot prepare ServerHello record");
      return res;
   }

   if (is_tls_ecdhe_ecdsa_with_aes_128_ccm_8(session.handshake_params.cipher)) 
   {
      var ecdsa_key;

      res = session.h.get_ecdsa_key(session, ecdsa_key);
      if (res < 0) 
      {
         dtls_crit("no ecdsa certificate to send in certificate");
         return res;
      }

      res = dtls_send_certificate_ecdsa(session, ecdsa_key);
      if (res < 0) 
      {
         dtls_warn("dtls_server_hello: cannot prepare Certificate record");
         return res;
      }

      res = dtls_send_server_key_exchange_ecdh(session, ecdsa_key);
      if (res < 0) 
      {
         dtls_warn("dtls_server_hello: cannot prepare Server Key Exchange record");
         return res;
      }

      if (is_tls_ecdhe_ecdsa_with_aes_128_ccm_8(session.handshake_params.cipher) && is_ecdsa_client_auth_supported(session)) 
      {
         res = dtls_send_server_certificate_request(session);
         if (res < 0) 
         {
            dtls_warn("dtls_server_hello: cannot prepare certificate Request record");
            return res;
         }
      }
   }

   if (is_tls_psk_with_aes_128_ccm_8(session.handshake_params.cipher)) 
   {
      var psk_hint = [0];

      res = dtls_send_server_key_exchange_psk(session, psk_hint);
      if (res < 0) 
      {
         dtls_warn("dtls_server_key_exchange_psk: cannot send server key exchange record");
         return res;
      }
   }

   res = dtls_send_server_hello_done(session);
   if (res < 0) 
   {
      dtls_warn("dtls_server_hello: cannot prepare ServerHelloDone record");
      return res;
   }
   return 0;
}

function dtls_send_certificate_verify_ecdh(session, key)
{
   //* The ASN.1 Integer representation of an 32 byte unsigned int could be
   //* 33 bytes long add space for that */
   var buf = [];
   var point_r = [];
   var point_s = [];
   var hs_hash = {};
   var sha256hash = [];
   
   dtls_debug("dtls_send_certificate_verify_ecdh() enter");
   var timeStart     = Math.floor(Date.now());  
   // ServerKeyExchange 
   copy_hs_hash(session.handshake_params.hs_state.hs_hash, hs_hash);
   dtls_hash_finalize(sha256hash, hs_hash);
   // sign the ephemeral and its paramaters */
   dtls_ecdsa_create_sig_hash(key.priv_key, dtls_config.DTLS_EC_KEY_SIZE,
              sha256hash, sha256hash.length,
              point_r, point_s);

   dtls_add_ecdsa_signature_elem(buf, point_r, point_s);
   var timeSinceStart = Math.floor(Date.now()) - timeStart;
   dtls_debug("dtls_send_certificate_verify_ecdh time (msec):"+timeSinceStart);
   var retv = dtls_send_handshake_msg(session, dtls_config.DTLS_HT_CERTIFICATE_VERIFY, buf);
   dtls_debug("dtls_send_certificate_verify_ecdh() exit");
   return retv;
}

function check_server_certificate(session, sdata)
{
   var err;
   var config = session.handshake_params;
   var idx = dtls_config.DTLS_HS_LENGTH;
   var data = [];
   var data_length = sdata.length;
   
   dtls_debug("check_server_certificate() enter");
   var timeStart     = Math.floor(Date.now());
   update_hs_hash(session, sdata);

   data = sdata.slice(idx, idx+3);

   if (dtls_uint24_to_int(data) != 94) 
   {
      dtls_alert("expect length of 94 bytes for server certificate message");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }
   idx += data.length;
   data = sdata.slice(idx, idx+3);
   
   if (dtls_uint24_to_int(data) != 91) 
   {
      dtls_alert("expect length of 91 bytes for certificate");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }
   idx += data.length;
   data = sdata.slice(idx, idx+cert_asn1_header.length);

   if (memcmp(data, cert_asn1_header, cert_asn1_header.length)) 
   {
      dtls_alert("got an unexpected Subject public key format");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }
   idx += data.length;
   data = sdata.slice(idx, idx+dtls_config.DTLS_EC_KEY_SIZE);
   
   memcpy(config.keyx.ecdsa.other_pub_x, data, data.length);
   idx += data.length;
   data = sdata.slice(idx, idx+dtls_config.DTLS_EC_KEY_SIZE);

   memcpy(config.keyx.ecdsa.other_pub_y, data, data.length);
   idx += data.length;

   err = session.h.verify_ecdsa_key(session, config.keyx.ecdsa.other_pub_x, 
      config.keyx.ecdsa.other_pub_y, config.keyx.ecdsa.other_pub_x.length);
   if (err < 0) 
   {
      dtls_warn("The certificate was not accepted");
      return err;
   }
   var timeSinceStart = Math.floor(Date.now()) - timeStart;
   dtls_debug("check_server_certificate time (msec):"+timeSinceStart);

   dtls_debug("check_server_certificate() exit");
   return 0;
}

function check_server_key_exchange_ecdsa(session, sdata, data_length)
{
   var config = session.handshake_params;
   var ret;
   var result_r = [];
   var result_s = [];
   var key_params;
   var idx = dtls_config.DTLS_HS_LENGTH;

   dtls_debug("check_server_key_exchange_ecdsa() enter");
   var timeStart     = Math.floor(Date.now());
   update_hs_hash(session, sdata);
   data = sdata.slice(idx, idx+1);
   if (data_length < dtls_config.DTLS_HS_LENGTH + dtls_config.DTLS_SKEXEC_LENGTH) 
   {
      dtls_alert("the packet length does not match the expected");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }
   key_params = idx;
   if (dtls_uint8_to_int(data) != dtls_config.TLS_EC_CURVE_TYPE_NAMED_CURVE) 
   {
      dtls_alert("Only named curves supported");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+2);
   if (dtls_uint16_to_int(data) != dtls_config.TLS_EXT_ELLIPTIC_CURVES_SECP256R1) 
   {
      dtls_alert("secp256r1 supported");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+1);
   if (dtls_uint8_to_int(data) != 1 + 2 * dtls_config.DTLS_EC_KEY_SIZE) 
   {
      dtls_alert("expected 65 bytes long public point");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+1);
   if (dtls_uint8_to_int(data) != 4) 
   {
      dtls_alert("expected uncompressed public point");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECODE_ERROR);
   }
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+dtls_config.DTLS_EC_KEY_SIZE);
   memcpy(config.keyx.ecdsa.other_eph_pub_x, data, data.length);
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+dtls_config.DTLS_EC_KEY_SIZE);
   memcpy(config.keyx.ecdsa.other_eph_pub_y, data, data.length);
   idx += data.length;
   data_length -= data.length;
   data = sdata.slice(idx, idx+data_length);
   ret = dtls_check_ecdsa_signature_elem(data, data_length, result_r, result_s);
   if (ret < 0) 
   {
      dtls_alert("wrong signature elem");
      return ret;
   }
   idx += ret;
   data_length -= ret;

   data= sdata.slice(key_params, key_params+1 + 2 + 1 + 1 + (2 * dtls_config.DTLS_EC_KEY_SIZE));
   ret = dtls_ecdsa_verify_sig(config.keyx.ecdsa.other_pub_x, config.keyx.ecdsa.other_pub_y,
               config.keyx.ecdsa.other_pub_x.length,
               config.tmp.random.client, dtls_config.DTLS_RANDOM_LENGTH,
               config.tmp.random.server, dtls_config.DTLS_RANDOM_LENGTH,
               data, data.length,
               result_r, result_s);
   if (ret < 0) 
   {
      dtls_alert("wrong signature");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }
   var timeSinceStart = Math.floor(Date.now()) - timeStart;
   dtls_debug("check_server_key_exchange_ecdsa time (msec):"+timeSinceStart);
   dtls_debug("check_server_key_exchange_ecdsa() exit");
   return 0;
}
 //DTLS_ECC_FEATURE end
function dtls_alert_fatal_create(desc)
{
     return dtls_alert_create(dtls_config.DTLS_ALERT_LEVEL_FATAL, desc);
}

function clear_hs_hash(session)
{
   dtls_hash_init(session.handshake_params.hs_state.hs_hash);
}

function dtls_send_handshake_msg_hash(session, header_type, data, add_hash)
{
   var data_length = data.length;    
   var buf;
   var data_array = [[],[]];
   var i = 0;

   buf = dtls_set_handshake_header(header_type, session, data_length, 0, data_length);
   if (add_hash) 
   {
      update_hs_hash(session, buf);
   }
   data_array[i] = buf;
   i++;

   if (data != null) 
   {
      if (add_hash) 
      {
         update_hs_hash(session, data);
      }
      data_array[i] = data;
      i++;
   }
   dtls_debug("send handshake packet of type: " + dtls_handshake_type_to_name(header_type) + "(" + header_type + ")");
   return dtls_send_multi(session, dtls_config.DTLS_CT_HANDSHAKE, data_array);
}

function dtls_send_handshake_msg(session, header_type, data)
{
   return dtls_send_handshake_msg_hash(session, header_type, data, 1);
}

function dtls_send_client_hello(session, cookie, cookie_length)
{
   dtls_debug('dtls_send_client_hello() enter');
   var buf = [];
   var cipher_size;
   var extension_size;
   var psk;
   var ecdsa;
   var handshake = session.handshake_params;
   var now;

   psk = is_psk_supported(session);
   ecdsa = is_ecdsa_supported(session, 1);

   cipher_size = 2 + ((ecdsa) ? 2 : 0) + ((psk) ? 2 : 0);
   extension_size = (ecdsa) ? 2 + 6 + 6 + 8 + 6: 0;

   if (cipher_size == 0) 
   {
      dtls_crit("no cipher callbacks implemented");
   }
   
   buf = buf.concat(dtls_int_to_uint16(dtls_config.DTLS_VERSION));
   
   if (cookie_length > dtls_config.DTLS_COOKIE_LENGTH_MAX) 
   {
      dtls_crit("the cookie is too long");
      return dtls_alert_fatal_create(dtls_config.DTLS_ALERT_HANDSHAKE_FAILURE);
   }

   if (cookie_length == 0) 
   {
      /* Set client random: First 4 bytes are the client's Unix timestamp,
      * followed by 28 bytes of generate random data. */
      now = dtls_ticks();    
      var u32 = Math.floor(now / dtls_config.CLOCK_SECOND);
      handshake.tmp.random.client = dtls_int_to_uint32(u32);
      handshake.tmp.random.client = handshake.tmp.random.client.concat(dtls_prng(dtls_config.DTLS_RANDOM_LENGTH - handshake.tmp.random.client.length));
   }
   
   /* we must use the same Client Random as for the previous request */
   buf = buf.concat(handshake.tmp.random.client);
   /* session id (length 0) */
   buf = buf.concat(dtls_int_to_uint8(0));
   /* cookie */
   buf = buf.concat(dtls_int_to_uint8(cookie_length));
   if (cookie_length != 0) 
   {
      buf = buf.concat(cookie);
   }
   /* add known cipher(s) */
   buf = buf.concat(dtls_int_to_uint16(cipher_size - 2));
   if (ecdsa) 
   {
      buf = buf.concat(dtls_int_to_uint16(dtls_config.TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8));
   }
   if (psk) 
   {
      buf = buf.concat(dtls_int_to_uint16(dtls_config.TLS_PSK_WITH_AES_128_CCM_8));
   }
   /* compression method */
   buf = buf.concat(dtls_int_to_uint8(1));
   buf = buf.concat(dtls_int_to_uint8(dtls_config.TLS_COMPRESSION_NULL));
   if (extension_size) 
   {
      /* length of the extensions */
      buf = buf.concat(dtls_int_to_uint16(extension_size - 2));
   }

   if (ecdsa) 
   {
      /* client certificate type extension */
      buf = buf.concat(dtls_int_to_uint16(dtls_config.TLS_EXT_CLIENT_CERTIFICATE_TYPE));
      /* length of this extension type */
      buf = buf.concat(dtls_int_to_uint16(2));
      /* length of the list */
      buf = buf.concat(dtls_int_to_uint8(1));
      buf = buf.concat(dtls_int_to_uint8(dtls_config.TLS_CERT_TYPE_RAW_PUBLIC_KEY));
      /* client certificate type extension */
      buf = buf.concat(dtls_int_to_uint16(dtls_config.TLS_EXT_SERVER_CERTIFICATE_TYPE));
      /* length of this extension type */
      buf = buf.concat(dtls_int_to_uint16(2));
      /* length of the list */
      buf = buf.concat(dtls_int_to_uint8(1));
      buf = buf.concat(dtls_int_to_uint8(dtls_config.TLS_CERT_TYPE_RAW_PUBLIC_KEY));
      /* elliptic_curves */
      buf = buf.concat(dtls_int_to_uint16(dtls_config.TLS_EXT_ELLIPTIC_CURVES));
      /* length of this extension type */
      buf = buf.concat(dtls_int_to_uint16(4));
      /* length of the list */
      buf = buf.concat(dtls_int_to_uint16(2));
      buf = buf.concat(dtls_int_to_uint16(dtls_config.TLS_EXT_ELLIPTIC_CURVES_SECP256R1));
      /* ec_point_formats */
      buf = buf.concat(dtls_int_to_uint16(dtls_config.TLS_EXT_EC_POINT_FORMATS));
      /* length of this extension type */
      buf = buf.concat(dtls_int_to_uint16(2));
      /* number of supported formats */
      buf = buf.concat(dtls_int_to_uint8(1));
      buf = buf.concat(dtls_int_to_uint8(dtls_config.TLS_EXT_EC_POINT_FORMATS_UNCOMPRESSED));
   }

   if (cookie_length != 0)
   {
      clear_hs_hash(session);
   }
   dtls_debug('dtls_send_client_hello() exit');
   return dtls_send_handshake_msg_hash(session, dtls_config.DTLS_HT_CLIENT_HELLO, buf, cookie_length != 0);
}

function dtls_renegotiate(session)
{
   if (session.state != dtls_config.DTLS_STATE_CONNECTED)
   {
      return -1;
   }

   session.handshake_params.hs_state.mseq_r = 0;
   session.handshake_params.hs_state.mseq_s = 0;

   if (session.role == dtls_config.DTLS_CLIENT) 
   {
      /* send ClientHello with empty Cookie */
      err = dtls_send_client_hello(session, null, 0);
      if (err < 0)
      {
         dtls_warn("cannot send ClientHello");
      }
      else
      {
         session.state = dtls_config.DTLS_STATE_CLIENTHELLO;
      }
      return err;
   } 
   else if (session.role == dtls_config.DTLS_SERVER) 
   {
      return dtls_send_hello_request(session);
   }

   return -1;
}


function dtls_connect_peer(session)
{
   dtls_debug('dtls_connect_peer() enter');
   var res = -1;
          
   if (session)
   {  
	   /* check if the same peer is already in our list */
	   if (session.state == dtls_config.DTLS_STATE_CONNECTED) 
	   {
	      dtls_info("found peer, try to re-connect");
	      return dtls_renegotiate(session);
	   }
	   
	   /* send ClientHello with empty Cookie */
	   session.handshake_params.hs_state.mseq_r = 0;
	   session.handshake_params.hs_state.mseq_s = 0;
	   res = dtls_send_client_hello(session, null, 0);
	   if (res < 0)
	   {
	      dtls_warn("cannot send ClientHello");
	   }
	   else 
	   {
	      session.state = dtls_config.DTLS_STATE_CLIENTHELLO;
	   }   
   }
   
   dtls_debug('dtls_connect_peer() exit');
   return res;
}

function dtls_prng_init(seed)
{
   /* random_init() messes with the radio interface of the CC2538 and
    * therefore must not be called after the radio has been
    * initialized. */
}


function dtls_ticks()
{
   return Date.now();
}


function dtls_handle_retransmit(node)
{
   dtls_debug("Started DTLS retransmit process");
   if (netq_node_find(node) >= 0)
   {
      netq_node_free(node);
      dtls_retransmit(node);
   }
}

function etimer_set(node)
{  var that = node;
   dtls_debug("etimer_set() enter");
   if (node)
   {
      dtls_debug("etimer_set(): setTimeout called");
      node.retransmit_timer = setTimeout(function() 
      {
         //Time out handler code here:
         dtls_debug("++++++++++++DTLS timer expired+++++++++++++++++++");
         dtls_handle_retransmit(that);
      }, node.timeout);
   }
   dtls_debug("etimer_set() exit");
}

function etimer_stop(node)
{
   dtls_debug("etimer_stop() enter");
   if (node && node.retransmit_timer) 
   {
      dtls_debug("etimer_stop(): clearTimeout called");
      clearTimeout(node.retransmit_timer);
      node.retransmit_timer = null;
   }
   
   dtls_debug("etimer_stop() exit");
}

function dtls_set_record_header(type, security)
{  
   var buf = [];
   
   buf = buf.concat(dtls_int_to_uint8(type));
   buf = buf.concat(dtls_int_to_uint16(dtls_config.DTLS_VERSION));
   if (security) 
   {
      buf = buf.concat(dtls_int_to_uint16(security.epoch));
      buf = buf.concat(dtls_int_to_uint48(security.rseq));

      /* increment record sequence counter by 1 */
      security.rseq++;
   } 
   else 
   {
      memset(buf, 0, 2 + 6, buf.length);
   }

   buf = buf.concat([0,0]);
   return buf;  
}

function is_tls_psk_with_aes_128_ccm_8(cipher)
{
   return cipher == dtls_config.TLS_PSK_WITH_AES_128_CCM_8;
}

function is_tls_ecdhe_ecdsa_with_aes_128_ccm_8(cipher)
{
   return cipher == dtls_config.TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8;
}
 //DTLS_ECC_FEATURE begin
//** Returns true if the application is configured for ecdhe_ecdsa with
// * client authentication 
function is_ecdsa_client_auth_supported(ctx)
{
   if (dtls_config.DTLS_ECC_SUPPORT)
   {
       return ctx && ctx.h && ctx.h.get_ecdsa_key && ctx.h.verify_ecdsa_key;
   }
   else
   {
      return 0;
   }
}
 //DTLS_ECC_FEATURE end
function DTLS_RECORD_HEADER(msg)
{
   var hdr = {};

   hdr.content_type = [msg[0]];  //< content type of the included message 
   hdr.version = msg.slice(1,1+2);   //< Protocol version 
   hdr.epoch = msg.slice(3,3+2);   //< counter for cipher state changes 
   hdr.sequence_number = msg.slice(5, 5+6);  //< sequence number 
   hdr.length = msg.slice(11, 11+2);  //< length of the following fragment 

   return(hdr);
}

function dtls_kb_client_mac_secret(Param, Role)
{
   var key = Param.key_block;
   return (key.slice(0, key.length));
}

function dtls_kb_server_mac_secret(Param, Role)
{
   var key = Param.key_block;
   return (key.slice(dtls_config.DTLS_MAC_KEY_LENGTH, key.length));
}

function dtls_kb_remote_mac_secret(Param, Role)
{
   var key = (Role == dtls_config.DTLS_SERVER
      ? dtls_kb_client_mac_secret(Param, Role) 
      : dtls_kb_server_mac_secret(Param, Role));
   return key;
}

function dtls_kb_local_mac_secret(Param, Role)
{
   return (Role == dtls_config.DTLS_CLIENT 
      ? dtls_kb_client_mac_secret(Param, Role)  
      : dtls_kb_server_mac_secret(Param, Role));
}

function dtls_kb_mac_secret_size(Param, Role) 
{
   return dtls_config.DTLS_MAC_KEY_LENGTH;
}
  

function dtls_kb_client_write_key(Param, Role)
{
   var key = dtls_kb_server_mac_secret(Param, Role);
   return key.slice(dtls_config.DTLS_MAC_KEY_LENGTH, 
                    dtls_config.DTLS_MAC_KEY_LENGTH + dtls_config.DTLS_KEY_LENGTH);
}

function dtls_kb_server_write_key(Param, Role)
{
   var key = dtls_kb_server_mac_secret(Param, Role);
   return key.slice(dtls_config.DTLS_MAC_KEY_LENGTH +   dtls_config.DTLS_KEY_LENGTH,  
                    dtls_config.DTLS_MAC_KEY_LENGTH + 2*dtls_config.DTLS_KEY_LENGTH);
}

function dtls_kb_local_write_key(Param, Role)
{
   var key = (Role == dtls_config.DTLS_CLIENT ? dtls_kb_client_write_key(Param, Role) : dtls_kb_server_write_key(Param, Role));
   return key;
}

function dtls_kb_remote_write_key(Param, Role)
{
   var key = (Role == dtls_config.DTLS_SERVER
   ? dtls_kb_client_write_key(Param, Role)
   : dtls_kb_server_write_key(Param, Role));
   return key;
}

function dtls_kb_client_iv(Param, Role)
{
   var iv = dtls_kb_server_mac_secret(Param, Role);
   return iv.slice(dtls_config.DTLS_MAC_KEY_LENGTH + 2*dtls_config.DTLS_KEY_LENGTH, 
                   dtls_config.DTLS_MAC_KEY_LENGTH + 2*dtls_config.DTLS_KEY_LENGTH + dtls_config.DTLS_IV_LENGTH);
}

function dtls_kb_server_iv(Param, Role)
{
   var iv = dtls_kb_server_mac_secret(Param, Role);
   return iv.slice(dtls_config.DTLS_MAC_KEY_LENGTH + 2*dtls_config.DTLS_KEY_LENGTH +   dtls_config.DTLS_IV_LENGTH, 
                   dtls_config.DTLS_MAC_KEY_LENGTH + 2*dtls_config.DTLS_KEY_LENGTH + 2*dtls_config.DTLS_IV_LENGTH);
}

function dtls_kb_local_iv(Param, Role)
{
   var iv = (Role == dtls_config.DTLS_CLIENT ? dtls_kb_client_iv(Param, Role) : dtls_kb_server_iv(Param, Role));
   return iv;
}

function dtls_kb_remote_iv(Param, Role)
{
   var iv = (Role == dtls_config.DTLS_SERVER
   ? dtls_kb_client_iv(Param, Role)
   : dtls_kb_server_iv(Param, Role));
   return iv;
}

function dtls_send_multi(session, type, msgs, outf)
{ 
   var sendbuf = dtls_prepare_record(session, type, msgs);

   if (!sendbuf)
   {
      return -1;
   }

   var overall_len = 0;
   for (var i = 0; i < msgs.length; i++) 
   {
      overall_len += msgs[i].length;
   }
   
   if ((type == dtls_config.DTLS_CT_HANDSHAKE && msgs[0][0] != dtls_config.DTLS_HT_HELLO_VERIFY_REQUEST) ||
      type == dtls_config.DTLS_CT_CHANGE_CIPHER_SPEC) 
   {
      /* copy handshake messages other than HelloVerify into retransmit buffer */
      var n = {};
      var now = dtls_ticks();
      
      n.t = now + dtls_config.RETRANSMIT_TIMEOUT;
      n.retransmit_cnt = 0;
      n.timeout = dtls_config.RETRANSMIT_TIMEOUT;

      n.session = session;
      n.epoch = (session.security_params) ? session.security_params.epoch : 0;
      n.type = type;
      n.data = [];
      for (var i = 0; i < msgs.length; i++) 
      {
         n.data = n.data.concat(msgs[i]);
      }
      n.length = n.data.length;
      
      if (!netq_insert_node(n)) 
      {
         dtls_warn("cannot add packet to retransmit buffer");
      } 
      else 
      {
         etimer_set(n);
      }   
   }
   
   var res = (session.h && session.h.write) ?  session.h.write(session, sendbuf, outf) : -1;
   
   return res <= 0 ? res : overall_len - (sendbuf.length - res);
}

function dtls_send(session, msg_type, msg, outf)
{
   var retV;
   dtls_debug("dtls_send() enter");
   retV = dtls_send_multi(session, msg_type, [msg], outf);
   dtls_debug("dtls_send() exit");
   return retV;
}

function dtls_prepare_record(session, type, data_array) 
{
   var sendbuf = [];
   var security = session.security_params;
   var start;
   var res = 0;
   var i;

   sendbuf = dtls_set_record_header(type, security);
   start = sendbuf.length;

   if (!security || security.cipher == dtls_config.TLS_NULL_WITH_NULL_NULL) 
   {
      // no cipher suite 
      for (i = 0; i < data_array.length; i++) 
      {
         sendbuf = sendbuf.concat(data_array[i]);
      }
      res = sendbuf.length - start;
   } 
   else 
   { 
      var nonce = [];
      var A_DATA = [];

      if (is_tls_psk_with_aes_128_ccm_8(security.cipher)) 
      {
         dtls_info("dtls_prepare_record(): encrypt using TLS_PSK_WITH_AES_128_CCM_8");
      } 
      else if (is_tls_ecdhe_ecdsa_with_aes_128_ccm_8(security.cipher)) 
      {
         dtls_info("dtls_prepare_record(): encrypt using TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8");
      } 
      else 
      {
         dtls_info("dtls_prepare_record(): encrypt using unknown cipher");
      }

      var dtlsRecordHeader = DTLS_RECORD_HEADER(sendbuf);
      var epoch = dtlsRecordHeader.epoch;
      
      sendbuf = sendbuf.concat(epoch);  
      sendbuf = sendbuf.concat(dtlsRecordHeader.sequence_number);   
      for (i = 0; i < data_array.length; i++) 
      {
         sendbuf = sendbuf.concat(data_array[i]);
      }

      memset(nonce, 0, dtls_config.DTLS_CCM_BLOCKSIZE);
      var dkli = dtls_kb_local_iv(security, session.role);
      memcpy(nonce, dkli, dkli.length);
      memcpy(nonce, sendbuf, 8, dkli.length, start); //* epoch + seq_num 
      memcpy(A_DATA, epoch, epoch.length); //  
      memcpy(A_DATA, dtlsRecordHeader.sequence_number, dtlsRecordHeader.sequence_number.length, epoch.length, 0); //seq
      memcpy(A_DATA, dtlsRecordHeader.content_type, 1, 8, 0); //type and version 
      memcpy(A_DATA, dtlsRecordHeader.version, 2, 9, 0); //type and version 
      
      res = sendbuf.length - start;
      var ll = dtls_int_to_uint16(res - 8)
      memcpy(A_DATA, ll, ll.length, 11, 0); //length 
      
      var wkey = dtls_kb_local_write_key(security, session.role);
      res = dtls_encrypt(sendbuf, start + 8, res - 8, sendbuf, start + 8, nonce, wkey, A_DATA);

      if (res < 0)
      {
         return null;
      }

      res += 8;        //increment res by size of nonce_explicit 
   }

   //fix length of fragment in sendbuf 
   ll = dtls_int_to_uint16(res);
   memcpy(sendbuf, ll, ll.length, 11, 0);

   return sendbuf;
}

function is_record(msg)
{
   var rlen = 0;
   var msglen = msg.length;

   if (msglen >= dtls_config.DTLS_RH_LENGTH   
      && dtls_config.content_types.includes(msg[0])
      && msg[1] == Math.floor(dtls_config.DTLS_VERSION / 256)
      && msg[2] == (dtls_config.DTLS_VERSION % 256) 
      )
   {
      rlen = dtls_config.DTLS_RH_LENGTH + dtls_config.dtls_uint16_to_int(DTLS_RECORD_HEADER(msg).length);
       
      //we do not accept wrong length field in record header 
      if (rlen > msglen) 
      {
         rlen = 0;
      }
   } 
   
   return rlen;
}

function dtls_stop_retransmission(session)
{
   if (session)
   {
      while (session.sendqueue.length > 0)
      {
         etimer_stop(session.sendqueue[0]);
         netq_node_free(session.sendqueue[0]);
      }
   }
}

module.exports.dtls_write = function(session, msg, outf) 
{  
   dtls_debug("dtls_write() enter");
   var retV = false;
   
   if (session.state == dtls_config.DTLS_STATE_CONNECTED) 
   {
      retV = (dtls_send(session, dtls_config.DTLS_CT_APPLICATION_DATA, msg, outf) >= 0);
   }
   
   dtls_debug("dtls_write() exit");
   return retV;
}


module.exports.dtls_handle_message = function (session, bmsg, outbuf) 
{ 
   dtls_debug('dtls_handle_message enter');
  
   var rlen;    /* record length */
   var data;          /* (decrypted) payload */
   var err;
   var msg = Array.from(bmsg);
   
   while ((rlen = is_record(msg))) 
   {
      var role;
      var state;

      dtls_debug("got packet " + msg[0] + "(" + rlen + "bytes)");
      if (!(msg[0] == dtls_config.DTLS_CT_HANDSHAKE && msg[dtls_config.DTLS_RH_LENGTH] == dtls_config.DTLS_HT_CLIENT_HELLO) 
            && msg[0] != dtls_config.DTLS_CT_ALERT) 
      {
         data = decrypt_verify(session, msg, rlen);
         if (!data) 
         {
            err =  dtls_alert_fatal_create(dtls_config.DTLS_ALERT_DECRYPT_ERROR);
            dtls_info("decrypt_verify() failed");
            //if (session.state < dtls_config.DTLS_STATE_CONNECTED) 
            {
               dtls_alert_send_from_err(session, err);
               session.state = dtls_config.DTLS_STATE_CLOSED;
               dtls_destroy_peer(session, 1);
            }
            return err;
         }
         role = session.role;
         state = session.state;
      } 
      else 
      {
         /* is_record() ensures that msg contains at least a record header */
         data = msg.slice(dtls_config.DTLS_RH_LENGTH, rlen);
         state = dtls_config.DTLS_STATE_WAIT_CLIENTHELLO;
         role = dtls_config.DTLS_SERVER;
      }

      /* Handle received record according to the first byte of the
      * message, i.e. the subprotocol. We currently do not support
      * combining multiple fragments of one type into a single
      * record. */
      switch (msg[0]) 
      {
      case dtls_config.DTLS_CT_CHANGE_CIPHER_SPEC:
         dtls_stop_retransmission(session);
         err = handle_ccs(session, msg, data);
         if (err < 0) 
         {
            dtls_warn("error while handling ChangeCipherSpec message");
            dtls_alert_send_from_err(session, err);

            /* invalidate peer */
            dtls_destroy_peer(session, 1);
            return err;
         }
         break;

      case dtls_config.DTLS_CT_ALERT:
         dtls_stop_retransmission(session);
         err = handle_alert(session, msg, data);
         if (err < 0 || err == 1) 
         {
            dtls_warn("received alert, peer has been invalidated");
            /* handle alert has invalidated peer */
            return err < 0 ?err:-1;
         }
         break;

      case dtls_config.DTLS_CT_HANDSHAKE:
         dtls_stop_retransmission(session);
         /* Handshake messages other than Finish must use the current
         * epoch, Finish has epoch + 1. */

         if (data[0] != dtls_config.DTLS_HT_CLIENT_HELLO) 
         {
            /* The new security parameters must be used for all messages
            * that are sent after the ChangeCipherSpec message. This
            * means that the client's Finished message uses epoch + 1
            * while the server is still in the old epoch.
            */
            if (role == dtls_config.DTLS_SERVER && state == dtls_config.DTLS_STATE_WAIT_FINISHED) 
            {
               session.security_params.epoch++;
            }
            
            var msg_epoch = dtls_config.dtls_uint16_to_int(DTLS_RECORD_HEADER(msg).epoch);
            var expected_epoch = session.security_params.epoch;
            if (expected_epoch != msg_epoch) 
            {
               dtls_warn("Wrong epoch, expected " + expected_epoch + ", got: " + msg_epoch);
               break;
            }
         }

         err = handle_handshake(session, role, state, data);
         if (err < 0) 
         {
            dtls_warn("error while handling handshake packet");
            dtls_alert_send_from_err(session, err);
            return err;
         }
         if (session.state == dtls_config.DTLS_STATE_CONNECTED) 
         {
        	session.numberOfConnectionSuccess++;
        	session.numberOfConnectionTries = 0;
            if (session.h && session.h.event) 
            {
            	session.h.event(session, 0, dtls_config.DTLS_EVENT_CONNECTED);
            }
         }
         break;

      case dtls_config.DTLS_CT_APPLICATION_DATA:
         dtls_stop_retransmission(session);
         dtls_debug("** application data:");

         if(outbuf)
         {
        	memcpy(outbuf, data, data.length);
         }
         break;
      default:
         dtls_info("dropped unknown message of type " + msg[0]);
      }

      /* advance msg by length of ciphertext */
      msg.splice(0, rlen);
   }
   
   dtls_debug('dtls_handle_message exit');
   return 0;
}

module.exports.dtls_new_context = function()
{
   var c = 
   {
      cookie_secret: [],
      cookie_secret_age: 0, /**< the time the secret has been generated */
   };      
   var now = dtls_ticks();

   dtls_prng_init(now);  
   c.cookie_secret = c.cookie_secret.concat(dtls_prng(dtls_config.DTLS_COOKIE_SECRET_LENGTH));
   c.cookie_secret_age = now;
  
   return c;
}

module.exports.dtls_connect = function(session)
{
   dtls_debug('dtls_connect() enter');
   var res = -1;
   
   if (!session.do_not_connect)
   {
      if (session.numberOfConnectionTries == dtls_config.MAX_CONNECTION_TRIES)
      {   
         session.do_not_connect = true;
         if (dtls_config.KEEP_TRY_CONNECTION)
    	 {
        	 setTimeout(function()
             {
    		    session.numberOfConnectionTries = 0;
    			session.do_not_connect = false;
    	     }, 5*60);	    //Do not attempt connect again for 5 minutes        	 
    	 }
	  }
      else
      {
         session.numberOfConnectionAttempts++;
         session.numberOfConnectionTries++;
	     res = dtls_connect_peer(session);
      }
   }

   dtls_debug('dtls_connect() exit');
   return res;
}