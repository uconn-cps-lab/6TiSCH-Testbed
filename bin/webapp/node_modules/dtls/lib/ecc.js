
//const addon                   = require('../../../build/Release/addon');

var dtls_config               = require('dtls/dtls_config.js');
var memset                    = require('dtls/dtls_config').memset;
var memcpy                    = require('dtls/dtls_config').memcpy;
var dtls_int_to_uint8         = require('dtls/dtls_config').dtls_int_to_uint8;
var dtls_int_to_uint16        = require('dtls/dtls_config').dtls_int_to_uint16;
var dtls_int_to_uint24        = require('dtls/dtls_config').dtls_int_to_uint24;
var dtls_int_to_uint32        = require('dtls/dtls_config').dtls_int_to_uint32;
var dtls_int_to_uint48        = require('dtls/dtls_config').dtls_int_to_uint48;
var dtls_uint8_to_int         = require('dtls/dtls_config').dtls_uint8_to_int;
var dtls_uint16_to_int        = require('dtls/dtls_config').dtls_uint16_to_int;
var dtls_uint24_to_int        = require('dtls/dtls_config').dtls_uint24_to_int;
var dtls_uint32_to_int        = require('dtls/dtls_config').dtls_uint32_to_int;
var dtls_info                 = require('dtls/dtls_config').dtls_info;
var dtls_warn                 = require('dtls/dtls_config').dtls_warn;
var dtls_debug                = require('dtls/dtls_config').dtls_debug;
var dtls_crit                 = require('dtls/dtls_config').dtls_crit;

var MAXINT = 0x100000000;
var arrayLength = 8;

//finite field functions
//FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF
var ecc_prime_m = 
   [0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
    0x00000000, 0x00000000, 0x00000001, 0xffffffff];

                  
// This is added after an static byte addition if the answer has a carry in MSB
var ecc_prime_r = 
   [0x00000001, 0x00000000, 0x00000000, 0xffffffff,
    0xffffffff, 0xffffffff, 0xfffffffe, 0x00000000];

//ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551
var ecc_order_m = 
   [0xFC632551, 0xF3B9CAC2, 0xA7179E84, 0xBCE6FAAD,
    0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF,
    0x00000000];

var ecc_order_r = 
   [0x039CDAAF, 0x0C46353D, 0x58E8617B, 0x43190552,
    0x00000000, 0x00000000, 0xFFFFFFFF, 0x00000000];

var ecc_order_mu = 
   [0xEEDF9BFE, 0x012FFD85, 0xDF1A6C21, 0x43190552,
    0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFF, 0x00000000,
    0x00000001];

var ecc_order_k = 8;

var ecc_g_point_x = 
   [0xD898C296, 0xF4A13945, 0x2DEB33A0, 0x77037D81,
    0x63A440F2, 0xF8BCE6E5, 0xE12C4247, 0x6B17D1F2];
var ecc_g_point_y = 
   [0x37BF51F5, 0xCBB64068, 0x6B315ECE, 0x2BCE3357,
    0x7C0F9E16, 0x8EE7EB4A, 0xFE1A7F9B, 0x4FE342E2];

//=================================================
function add(x, y, result, length)
{
   var d = 0; 
   for(var v = 0; v < length; v++)
   {
      d += x[v] + y[v]; 
      if (d >= MAXINT)
      {
         result[v] = d - MAXINT;
         d = 1;  //carry
      }
      else
      {
         result[v] = d;
         d = 0;
      }
   }
   return d;
}

function sub(x, y, result, length)
{
   var d = 0;
   for(var v = 0; v < length; v++)
   {
      d = x[v] - y[v] - d;
      if (d < 0)
      {
         result[v] = d + MAXINT;  //borrow
         d = 1;
      }
      else
      {
         result[v] = d;
         d = 0;      
      }
   }  
   return d;
}

function mult(x, y)
{
   var z = [];
   var xl = x % 65536;
   var xh = Math.floor(x/65536);
   var yl = y % 65536;
   var yh = Math.floor(y/65536);
   var p;;
   
   z[0] = xl*yl;
   z[1] = xh*yh;
   p = xl*yh;
   z[0] += (p % 65536)*65536;
   z[1] += Math.floor(p/65536);
   p = xh*yl;
   z[0] += (p % 65536)*65536;
   z[1] += Math.floor(p/65536);
   p = Math.floor(z[0]/MAXINT);
   z[0] = z[0] % MAXINT;
   z[1] += p;
   
   return z;
}

function rshiftby(innum, in_size, outnum, out_size, shift) 
{
   var i;
   for (i = 0; i < (in_size - shift) && i < out_size; i++)
   {
      outnum[i] = innum[i + shift];
   }
   for (; i < out_size; i++)
   {
      outnum[i] = 0;
   }
}

function setZero(A, length)
{
   memset(A, 0x0, length);
}

// copy one array to another
function copy(from, to, length)
{
   memcpy(to, from, length);
}

function isSame(A, B, length)
{
   var result = true;
   for (var i = 0; i < length; i++)
   {
      if (A[i] != B[i])
      {
         result = false;
         break;
      }
   }
   return result;
}

//is A greater than B?
function isGreater(A, B, length)
{
   var result = 0;
   for (var i = length - 1; i >= 0; --i)
   {
      if(A[i] > B[i])
      {
         result = 1;
         break;
      }
      else if(A[i] < B[i])
      {
         result = -1;
         break;
      }
   }
   return result;
}

function fieldAdd(x, y, reducer, result)
{
   if(add(x, y, result, arrayLength))
   { 
      //add prime if carry is still set!
      var tempas=[];
      setZero(tempas, 8);
      add(result, reducer, tempas, arrayLength);
      copy(tempas, result, arrayLength);
   }
   return 0;
}

function fieldSub(x, y, modulus, result)
{
   if(sub(x, y, result, arrayLength))
   { 
      //add modulus if carry is set
      var tempas = [];
      setZero(tempas, 8);
      add(result, modulus, tempas, arrayLength);
      copy(tempas, result, arrayLength);
   }
   return 0;
}

//finite Field multiplication
//32bit * 32bit = 64bit
function fieldMult(x, y, result, length)
{
   var temp = []; 
   var result_t = [];
   
   setZero(temp, length * 2);
   setZero(result, length * 2);
   
   var prod = [];
   for (var k = 0; k < length; k++)
   {
      for (var n = 0; n < length; n++)
      { 
         prod = mult(x[n], y[k]);
         temp[n+k] = prod[0];
         temp[n+k+1] = prod[1];
                
         result_t = [];
         add(temp, result, result_t, length * 2);
         memcpy(result, result_t, length * 2);

         setZero(temp, length * 2);
      }
   }
   
   return 0;
}

function fieldModP(A, B)
{
   var tempm = [];
   var tempm2 = [];
   var n;
   setZero(tempm, 8);
   setZero(tempm2, 8);
   // A = T 
   copy(B, A, arrayLength);

   // Form S1  
   for(n = 0; n < 3; n++)
   {
      tempm[n] = 0; 
   }
   for(n = 3; n < 8; n++)
   {
      tempm[n] = B[n+8];
   }

   // tempm2=T+S1 
   fieldAdd(A, tempm, ecc_prime_r, tempm2);
   // A=T+S1+S1 
   fieldAdd(tempm2, tempm, ecc_prime_r, A);
   // Form S2 
   for(n = 0; n < 3; n++) 
   {
      tempm[n] = 0; 
   }
   for(n = 3; n < 7; n++)
   {
      tempm[n] = B[n+9];
   }
   for(n = 7; n < 8; n++)
   {
      tempm[n] = 0;
   }
   // tempm2=T+S1+S1+S2 */ 
   fieldAdd(A, tempm, ecc_prime_r, tempm2);
   //* A=T+S1+S1+S2+S2 
   fieldAdd(tempm2, tempm, ecc_prime_r, A);
   // Form S3 
   for(n = 0; n < 3; n++)
   {
      tempm[n] = B[n+8]; 
   }
   for(n = 3; n < 6; n++)
   {
      tempm[n] = 0; 
   }
   for(n = 6; n < 8; n++)
   {
      tempm[n] = B[n+8];
   }
   // tempm2=T+S1+S1+S2+S2+S3 
   fieldAdd(A, tempm, ecc_prime_r, tempm2);
   // Form S4 
   for(n = 0; n < 3; n++) 
   {
      tempm[n] = B[n+9]; 
   }
   for(n=3;n<6;n++) tempm[n]=B[n+10]; 
   for(n=6;n<7;n++) tempm[n]=B[n+7]; 
   for(n=7;n<8;n++) tempm[n]=B[n+1];
   // A=T+S1+S1+S2+S2+S3+S4 
   fieldAdd(tempm2,tempm,ecc_prime_r,A);
   // Form D1 
   for(n=0;n<3;n++) tempm[n]=B[n+11]; 
   for(n=3;n<6;n++) tempm[n]=0; 
   for(n=6;n<7;n++) tempm[n]=B[n+2]; 
   for(n=7;n<8;n++) tempm[n]=B[n+3];
   // tempm2=T+S1+S1+S2+S2+S3+S4-D1 
   fieldSub(A,tempm,ecc_prime_m,tempm2);
   // Form D2 
   for(n=0;n<4;n++) tempm[n]=B[n+12]; 
   for(n=4;n<6;n++) tempm[n]=0; 
   for(n=6;n<7;n++) tempm[n]=B[n+3]; 
   for(n=7;n<8;n++) tempm[n]=B[n+4];
   // A=T+S1+S1+S2+S2+S3+S4-D1-D2 
   fieldSub(tempm2,tempm,ecc_prime_m,A);
   // Form D3 
   for(n=0;n<3;n++) tempm[n]=B[n+13]; 
   for(n=3;n<6;n++) tempm[n]=B[n+5]; 
   for(n=6;n<7;n++) tempm[n]=0; 
   for(n=7;n<8;n++) tempm[n]=B[n+5];
   // tempm2=T+S1+S1+S2+S2+S3+S4-D1-D2-D3 
   fieldSub(A,tempm,ecc_prime_m,tempm2);
   // Form D4 
   for(n=0;n<2;n++) tempm[n]=B[n+14]; 
   for(n=2;n<3;n++) tempm[n]=0; 
   for(n=3;n<6;n++) tempm[n]=B[n+6]; 
   for(n=6;n<7;n++) tempm[n]=0; 
   for(n=7;n<8;n++) tempm[n]=B[n+6];
   // A=T+S1+S1+S2+S2+S3+S4-D1-D2-D3-D4 
   fieldSub(tempm2,tempm,ecc_prime_m,A);
   if(isGreater(A, ecc_prime_m, arrayLength) >= 0)
   {
      fieldSub(A, ecc_prime_m, ecc_prime_m, tempm);
      copy(tempm, A, arrayLength);
   }
}

//**
//* calculate the result = A mod n.
//* n is the order of the eliptic curve.
//* A and result could point to the same value
//*
//* A: input value (max size * 4 bytes)
//* result: result of modulo calculation (max 36 bytes)
//* size: size of A
//*
//* This uses the Barrett modular reduction as described in the Handbook 
//* of Applied Cryptography 14.42 Algorithm Barrett modular reduction, 
//* see http://cacr.uwaterloo.ca/hac/about/chap14.pdf and 
//* http://everything2.com/title/Barrett+Reduction
//*
//* b = 32 (bite size of the processor architecture)
//* mu (ecc_order_mu) was precomputed in a java program
//
function fieldModO(A, result, length) 
{
   // This is used for value q1 and q3
   var q1_q3 = [];
   // This is used for q2 and a temp var
   var q2_tmp = [];

   // return if the given value is smaller than the modulus
   if (length == arrayLength && isGreater(A, ecc_order_m, arrayLength) <= 0) 
   {
      copy(A, result, length);
      return;
   }

   rshiftby(A, length, q1_q3, 9, ecc_order_k - 1);

   fieldMult(ecc_order_mu, q1_q3, q2_tmp, 9);

   rshiftby(q2_tmp, 18, q1_q3, 8, ecc_order_k + 1);

   // r1 = first 9 blocks of A

   fieldMult(q1_q3, ecc_order_m, q2_tmp, 8);

   // r2 = first 9 blocks of q2_tmp

   sub(A, q2_tmp, result, 9);

   while (isGreater(result, ecc_order_m, 9) >= 0)
   {
      sub(result, ecc_order_m, result, 9);
   }
}

function isOne(A)
{
   var n; 
   for(n = 1; n < 8; n++) 
   {
      if (A[n]!=0) 
      {
         break;
      }
   }

   if ((n==8)&&(A[0]==1)) 
      return 1;
   else 
      return 0;
}

function isZero(A)
{
   var r = true;
   for(var n = 0; n < 8; n++)
   {
      if (A[n] != 0)
      {
         r = false;
         break;
      }
   }
   return r;
}

function rshift(A)
{
   var n;
   var nOld = 0;
   for (var i = 7; i >= 0; i--)
   {
      n = A[i] & 0x1;
      A[i] = Math.floor(A[i] / 2) + nOld;
      nOld = (n > 0) ? 0x80000000 : 0;
   }
}

function fieldAddAndDivide(x, modulus, reducer, result)
{
   var n = add(x, modulus, result, arrayLength);
   
   rshift(result);
   if(n)
   { 
      //add prime if carry is still set!
      result[7] += 0x80000000;//add the carry
      if (isGreater(result, modulus, arrayLength) == 1)
      {
         var tempas = [];
         setZero(tempas, 8);
         add(result, reducer, tempas, 8);
         copy(tempas, result, arrayLength);
      } 
   }
   return 0;
}

//*
//* Inverse A and output to B
//
function fieldInv(A, modulus, reducer, B)
{
   var u = [],v = [], x1 = [], x2 = [];
   var tempm = [];
   var tempm2 = [];
   
   setZero(tempm, 8);
   setZero(tempm2, 8);
   setZero(u, 8);
   setZero(v, 8);

   var t;
   copy(A,u,arrayLength); 
   copy(modulus,v,arrayLength); 
   setZero(x1, 8);
   setZero(x2, 8);
   x1[0]=1; 
   //* While u !=1 and v !=1 
   while ((isOne(u) || isOne(v))==0) 
   {
      while(!(u[0]&1)) 
      {               //* While u is even 
         rshift(u);                 //* divide by 2 
         if (!(x1[0]&1))               //*ifx1iseven
            rshift(x1);             //* Divide by 2 
         else 
         {
            fieldAddAndDivide(x1,modulus,reducer,tempm); //* tempm=x1+p 
            copy(tempm,x1,arrayLength);      //* x1=tempm 
            //rshift(x1);              //* Divide by 2 
         }
      } 
      while(!(v[0]&1)) 
      {               //* While v is even 
         rshift(v);                 //* divide by 2 
         if (!(x2[0]&1))               //*ifx1iseven
            rshift(x2);             //* Divide by 2 
         else
         {
            fieldAddAndDivide(x2,modulus,reducer,tempm); //* tempm=x1+p 
            copy(tempm,x2,arrayLength);         //* x1=tempm 
            //rshift(x2);              //* Divide by 2 
         }      
      }

      t=sub(u,v,tempm,arrayLength);             //* tempm=u-v 
      if (t==0) 
      {                   //* If u > 0 
         copy(tempm,u,arrayLength);                //* u=u-v 
         fieldSub(x1,x2,modulus,tempm);         //* tempm=x1-x2 
         copy(tempm,x1,arrayLength);               //* x1=x1-x2 
      } 
      else 
      {
         sub(v,u,tempm,arrayLength);         //* tempm=v-u 
         copy(tempm,v,arrayLength);                //* v=v-u 
         fieldSub(x2,x1,modulus,tempm);         //* tempm=x2-x1 
         copy(tempm,x2,arrayLength);               //* x2=x2-x1 
      }
   }

   if (isOne(u)) 
   {
      copy(x1,B,arrayLength); 
   } 
   else 
   {
      copy(x2,B,arrayLength);
   }
}

function ec_double(px, py, Dx, Dy)
{
   var tempA = [];
   var tempB = [];
   var tempC = [];
   var tempD = [];

   if(isZero(px) && isZero(py))
   {
      copy(px, Dx,arrayLength);
      copy(py, Dy,arrayLength);
      return;
   }

   fieldMult(px, px, tempD, arrayLength);
   fieldModP(tempA, tempD);
   setZero(tempB, 8);
   tempB[0] = 0x00000001;
   fieldSub(tempA, tempB, ecc_prime_m, tempC); //tempC = (qx^2-1)
   tempB[0] = 0x00000003;
   fieldMult(tempC, tempB, tempD, arrayLength);
   fieldModP(tempA, tempD);//tempA = 3*(qx^2-1)
   fieldAdd(py, py, ecc_prime_r, tempB); //tempB = 2*qy
   fieldInv(tempB, ecc_prime_m, ecc_prime_r, tempC); //tempC = 1/(2*qy)
   fieldMult(tempA, tempC, tempD, arrayLength); //tempB = lambda = (3*(qx^2-1))/(2*qy)
   fieldModP(tempB, tempD);

   fieldMult(tempB, tempB, tempD, arrayLength); //tempC = lambda^2
   fieldModP(tempC, tempD);
   fieldSub(tempC, px, ecc_prime_m, tempA); //lambda^2 - Px
   fieldSub(tempA, px, ecc_prime_m, Dx); //lambda^2 - Px - Qx

   fieldSub(px, Dx, ecc_prime_m, tempA); //tempA = qx-dx
   fieldMult(tempB, tempA, tempD, arrayLength); //tempC = lambda * (qx-dx)
   fieldModP(tempC, tempD);
   fieldSub(tempC, py, ecc_prime_m, Dy); //Dy = lambda * (qx-dx) - px
}

function ec_add(px, py, qx, qy, Sx, Sy)
{
   var tempA = [];
   var tempB = [];
   var tempC = [];
   var tempD = [];

   if(isZero(px) && isZero(py))
   {
      copy(qx, Sx,arrayLength);
      copy(qy, Sy,arrayLength);
      return;
   } 
   else if(isZero(qx) && isZero(qy)) 
   {
      copy(px, Sx,arrayLength);
      copy(py, Sy,arrayLength);
      return;
   }

   if(isSame(px, qx, arrayLength))
   {
      if(!isSame(py, qy, arrayLength))
      {
         setZero(Sx, 8);
         setZero(Sy, 8);
         return;
      } 
      else 
      {
         ec_double(px, py, Sx, Sy);
         return;
      }
   }

   fieldSub(py, qy, ecc_prime_m, tempA);
   fieldSub(px, qx, ecc_prime_m, tempB);
   fieldInv(tempB, ecc_prime_m, ecc_prime_r, tempB);
   fieldMult(tempA, tempB, tempD, arrayLength); 
   fieldModP(tempC, tempD); //tempC = lambda

   fieldMult(tempC, tempC, tempD, arrayLength); //tempA = lambda^2
   fieldModP(tempA, tempD);
   fieldSub(tempA, px, ecc_prime_m, tempB); //lambda^2 - Px
   fieldSub(tempB, qx, ecc_prime_m, Sx); //lambda^2 - Px - Qx

   fieldSub(qx, Sx, ecc_prime_m, tempB);
   fieldMult(tempC, tempB, tempD, arrayLength);
   fieldModP(tempC, tempD);
   fieldSub(tempC, qy, ecc_prime_m, Sy);
}

function ecc_ec_mult(px, py, secret, resultx, resulty)
{
   var result = addon.ecc_ec_mult(px, py, secret);
   copy(result.resultx, resultx, result.resultx.length);
   copy(result.resulty, resulty, result.resulty.length);
}

//**
//* Calculate the ecdsa signature.
//*
//* For a description of this algorithm see
//* https://en.wikipedia.org/wiki/Elliptic_Curve_DSA#Signature_generation_algorithm
//*
//* input:
//*  d: private key on the curve secp256r1 (32 bytes)
//*  e: hash to sign (32 bytes)
//*  k: random data, this must be changed for every signature (32 bytes)
//*
//* output:
//*  r: r value of the signature (36 bytes)
//*  s: s value of the signature (36 bytes)
//*
//* return:
//*   0: everything is ok
//*  -1: can not create signature, try again with different k.
//

function ecc_ecdsa_sign(d, e, k, r, s)
{
   var result = addon.ecc_ecdsa_sign(d, e, k);
   copy(result.r, r, result.r.length);
   copy(result.s, s, result.s.length);
   return result.ret;
}

//**
//* Verifies a ecdsa signature.
//*
//* For a description of this algorithm see
//* https://en.wikipedia.org/wiki/Elliptic_Curve_DSA#Signature_verification_algorithm
//*
//* input:
//*  x: x coordinate of the public key (32 bytes)
//*  y: y coordinate of the public key (32 bytes)
//*  e: hash to verify the signature of (32 bytes)
//*  r: r value of the signature (32 bytes)
//*  s: s value of the signature (32 bytes)
//*
//* return:
//*  0: signature is ok
//*  -1: signature check failed the signature is invalid
//
function ecc_ecdsa_validate(x, y, e, r, s)
{
   return addon.ecc_ecdsa_validate(x, y, e, r, s);
}

function ecc_is_valid_key(priv_key)
{
   return addon.ecc_is_valid_key(priv_key);
}

function ecc_ecdh(px, py, secret, resultx, resulty) 
{
	ecc_ec_mult(px, py, secret, resultx, resulty);
}

function ecc_gen_pub_key(priv_key, pub_x, pub_y)
{
	ecc_ec_mult(ecc_g_point_x, ecc_g_point_y, priv_key, pub_x, pub_y);
}

module.exports.ecc_ec_mult                   = ecc_ec_mult;
module.exports.ecc_ecdsa_sign                = ecc_ecdsa_sign;
module.exports.ecc_ecdsa_validate            = ecc_ecdsa_validate;
module.exports.ecc_is_valid_key              = ecc_is_valid_key;
module.exports.ecc_ecdh                      = ecc_ecdh;
module.exports.ecc_gen_pub_key               = ecc_gen_pub_key;
