var dtls_config               = require('dtls/dtls_config.js');
var memset                    = require('dtls/dtls_config').memset;
var memcpy                    = require('dtls/dtls_config').memcpy;
var dtls_int_to_uint8         = require('dtls/dtls_config').dtls_int_to_uint8;
var dtls_int_to_uint16        = require('dtls/dtls_config').dtls_int_to_uint16;
var dtls_int_to_uint24        = require('dtls/dtls_config').dtls_int_to_uint24;
var dtls_int_to_uint32        = require('dtls/dtls_config').dtls_int_to_uint32;
var dtls_int_to_uint48        = require('dtls/dtls_config').dtls_int_to_uint48;
var dtls_uint8_to_int         = require('dtls/dtls_config').dtls_uint8_to_int;
var dtls_uint16_to_int        = require('dtls/dtls_config').dtls_uint16_to_int;
var dtls_uint24_to_int        = require('dtls/dtls_config').dtls_uint24_to_int;
var dtls_uint32_to_int        = require('dtls/dtls_config').dtls_uint32_to_int;
var dtls_info                 = require('dtls/dtls_config').dtls_info;
var dtls_warn                 = require('dtls/dtls_config').dtls_warn;
var dtls_debug                = require('dtls/dtls_config').dtls_debug;
var dtls_crit                 = require('dtls/dtls_config').dtls_crit;

var MAXINT = 0x100000000;
/* Initial hash value H for SHA-256: */
var sha256_initial_hash_value = 
[
	0x6a09e667,
	0xbb67ae85,
	0x3c6ef372,
	0xa54ff53a,
	0x510e527f,
	0x9b05688c,
	0x1f83d9ab,
	0x5be0cd19
];

var K256 = 
[
   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
   0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
   0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
   0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
   0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
   0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
   0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
   0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
   0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function R(b,x)
{
   return (Math.floor((x) / Math.pow(2, (b))));
}

function L(b,x)
{
   return (((x) * Math.pow(2, (b))) % MAXINT);
}

function S32(b,x)
{
   return ((R(b,x) + L(32 - b, x))) % MAXINT;
}

function Sigma1_256(x)
{
   return ((S32(6, (x)) ^ S32(11, (x)) ^ S32(25, (x))) + MAXINT) % MAXINT;
}

function Sigma0_256(x)
{
   return ((S32(2, (x)) ^ S32(13, (x)) ^ S32(22, (x))) + MAXINT) % MAXINT;
}

function sigma0_256(x)
{
   return ((S32(7, (x)) ^ S32(18, (x)) ^ R(3, (x))) + MAXINT) % MAXINT;
}

function sigma1_256(x)
{
   return ((S32(17, (x)) ^ S32(19, (x)) ^ R(10,   (x))) + MAXINT) % MAXINT;
}

function Ch(x,y,z)
{
   return ((((x) & (y)) ^ ((~(x)) & (z))) + MAXINT) % MAXINT;
}

function Maj(x,y,z)
{
   return ((((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z))) + MAXINT) % MAXINT;
}

function SHA256_Transform(context, data)
{
      var a, b, c, d, e, f, g, h, s0 = 0, s1 = 0;
      var T1, T2, W256;
      var i, j;        

      i = j = 0;
      W256 = [];
      while (i < dtls_config.SHA256_BLOCK_LENGTH)
      {
         W256[j] = data[i]*0x1000000 + data[i+1]*0x10000 + data[i+2]*0x100 + data[i+3];
         i += 4;
         j++;
      }
      
      /* Initialize registers with the prev. intermediate value */
      a = context.state[0];
      b = context.state[1];
      c = context.state[2];
      d = context.state[3];
      e = context.state[4];
      f = context.state[5];
      g = context.state[6];
      h = context.state[7];
      
      j = 0;
      do 
      {
         /* Apply the SHA-256 compression function to update a..h */
         T1 = (h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[j]) % MAXINT;
         T2 = (Sigma0_256(a) + Maj(a, b, c)) % MAXINT;
         h = g;
         g = f;
         f = e;
         e = (d + T1) % MAXINT;
         d = c;
         c = b;
         b = a;
         a = (T1 + T2) % MAXINT;
         
         j++;
      } while (j < 16);

      do 
      {
         /* Part of the message block expansion: */
         s0 = W256[(j+1) % 16];
         s0 = sigma0_256(s0);
         s1 = W256[(j+14) % 16]; 
         s1 = sigma1_256(s1);

         //* Apply the SHA-256 compression function to update a..h
         var jx = j % 16;
         W256[jx] = (W256[jx] + s1 + W256[(j+9) % 16] + s0) % MAXINT;

         T1 = (h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[jx]) % MAXINT;
         T2 = (Sigma0_256(a) + Maj(a, b, c)) % MAXINT;
         
         h = g;
         g = f;
         f = e;
         e = (d + T1) % MAXINT;
         d = c;
         c = b;
         b = a;
         a = (T1 + T2) % MAXINT;

         j++;
      } while (j < 64);
      
      /* Compute the current intermediate hash value */
      context.state[0] = (context.state[0] + a) % MAXINT ;
      context.state[1] = (context.state[1] + b) % MAXINT;
      context.state[2] = (context.state[2] + c) % MAXINT;
      context.state[3] = (context.state[3] + d) % MAXINT;
      context.state[4] = (context.state[4] + e) % MAXINT;
      context.state[5] = (context.state[5] + f) % MAXINT;
      context.state[6] = (context.state[6] + g) % MAXINT;
      context.state[7] = (context.state[7] + h) % MAXINT;
}

module.exports.sha256_initial_hash_value = sha256_initial_hash_value;

module.exports.SHA256_Update = function(context, data) 
{
   var len = data.length;
   var freespace, usedspace;
   var data_offset = 0;
  
   if (len == 0) 
   {
      // Calling with no data is valid - we do nothing 
      return;
   }
   usedspace = Math.floor(context.bitcount / 8) % dtls_config.SHA256_BLOCK_LENGTH;
   if (usedspace > 0) 
   {
      // Calculate how much free space is available in the buffer 
      freespace = dtls_config.SHA256_BLOCK_LENGTH - usedspace;

      if (len >= freespace) 
      {
         // Fill the buffer completely and process it 
         memcpy(context.buffer, data, freespace, usedspace, 0);
         context.bitcount += (freespace * 8);
         len -= freespace;
         data_offset += freespace;
         SHA256_Transform(context, context.buffer);
      } 
      else 
      {
         // The buffer is not yet full 
         memcpy(context.buffer, data, len, usedspace, 0);
         context.bitcount += (len*8);
         // Clean up: 
         usedspace = freespace = 0;
         return;
      }
   }
   while (len >= dtls_config.SHA256_BLOCK_LENGTH) 
   {
      // Process as many complete blocks as we can 
      SHA256_Transform(context, data.slice(data_offset, data_offset + dtls_config.SHA256_BLOCK_LENGTH));
      context.bitcount += dtls_config.SHA256_BLOCK_LENGTH * 8;
      len -= dtls_config.SHA256_BLOCK_LENGTH;
      data_offset += dtls_config.SHA256_BLOCK_LENGTH;
   }
   if (len > 0) 
   {
      // There's left-overs, so save 'em 
      memcpy(context.buffer, data, len, 0, data_offset);
      context.bitcount += len * 8;
   }
}

module.exports.SHA256_Init = function(context) 
{
   context.state = [];
   context.buffer = [];
   
   memcpy(context.state, sha256_initial_hash_value, sha256_initial_hash_value.length);
   memset(context.buffer, 0, dtls_config.SHA256_BLOCK_LENGTH);
   context.bitcount = 0;
}

module.exports.SHA256_Final = function(digest, context) 
{
   var usedspace;
    
   usedspace = Math.floor(context.bitcount / 8) % dtls_config.SHA256_BLOCK_LENGTH;
   if (usedspace > 0) 
   {
      //* Begin padding with a 1 bit: 
      context.buffer[usedspace++] = 0x80;

      if (usedspace < dtls_config.SHA256_SHORT_BLOCK_LENGTH) 
      {
         //* Set-up for the last transform: 
         memset(context.buffer, 0, dtls_config.SHA256_SHORT_BLOCK_LENGTH - usedspace, usedspace);
      } 
      else 
      {
         if (usedspace < dtls_config.SHA256_BLOCK_LENGTH) 
         {
            memset(context.buffer, 0, dtls_config.SHA256_BLOCK_LENGTH - usedspace, usedspace);
         }
         //* Do second-to-last transform: 
         SHA256_Transform(context, context.buffer);

         // And set-up for the last transform: 
         memset(context.buffer, 0, dtls_config.SHA256_SHORT_BLOCK_LENGTH);
      }
   } 
   else 
   {
      // Set-up for the last transform: 
      memset(context.buffer, 0, dtls_config.SHA256_SHORT_BLOCK_LENGTH);

      // Begin padding with a 1 bit: 
      context.buffer[0] = 0x80;
   }
   
   /* Set the bit count: */
   var temp = context.bitcount;
   for (var i = 7; i >= 0; i--)
   {
      context.buffer[dtls_config.SHA256_SHORT_BLOCK_LENGTH + i] = temp % 256;
      temp = Math.floor(temp /256);
   }

   /* Final transform: */
   SHA256_Transform(context, context.buffer);
   for (var j = 0; j < 8; j++)
   {
      temp = context.state[j]
      for (var i = 3; i >= 0; i--)
      {
         digest[4*j + i] = temp % 256;
         temp = Math.floor(temp /256);
      }
   }

   /* Clean up state data: */
   memset(context.state, 0, context.state.length);
   memset(context.buffer, 0, context.buffer.length);
   context.bitcount = 0;
}