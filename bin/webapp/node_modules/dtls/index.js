/*
 * Copyright (c) 2015-2016, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var ipaddr                    = require('ipaddr.js');
var dgram                     = require('dgram');
var dtls_config               = require('dtls/dtls_config.js');
var dtls_handle_message       = require('dtls/lib/dtls_core').dtls_handle_message;
var dtls_write                = require('dtls/lib/dtls_core').dtls_write;
var dtls_new_context          = require('dtls/lib/dtls_core').dtls_new_context;
var dtls_connect              = require('dtls/lib/dtls_core').dtls_connect;
var memcpy                    = require('dtls/dtls_config').memcpy;
var dtls_info                 = require('dtls/dtls_config').dtls_info;
var dtls_warn                 = require('dtls/dtls_config').dtls_warn;
var dtls_debug                = require('dtls/dtls_config').dtls_debug;
var dtls_crit                 = require('dtls/dtls_config').dtls_crit;
var dtls_ec_key_from_uint32_asn1    = require('dtls/lib/crypto').dtls_ec_key_from_uint32_asn1;
var dtls_ecdh_pre_master_secret     = require('dtls/lib/crypto').dtls_ecdh_pre_master_secret;
var dtls_ecdsa_generate_key         = require('dtls/lib/crypto').dtls_ecdsa_generate_key;
var dtls_ecdsa_create_sig_hash      = require('dtls/lib/crypto').dtls_ecdsa_create_sig_hash;
var dtls_ecdsa_create_sig           = require('dtls/lib/crypto').dtls_ecdsa_create_sig;
var dtls_ecdsa_verify_sig_hash      = require('dtls/lib/crypto').dtls_ecdsa_verify_sig_hash;
var dtls_ecdsa_verify_sig           = require('dtls/lib/crypto').dtls_ecdsa_verify_sig;

var peerId = 0;
var sessions = [];
var psk =
   [
      {id: dtls_config.PSK_DEFAULT_IDENTITY, key:  dtls_config.PSK_DEFAULT_KEY}
   ];
var dtls_sock = null;
 //DTLS_ECC_FEATURE begin
var ecdsa_priv_key = [
0x41, 0xC1, 0xCB, 0x6B, 0x51, 0x24, 0x7A, 0x14,
0x43, 0x21, 0x43, 0x5B, 0x7A, 0x80, 0xE7, 0x14,
0x89, 0x6A, 0x33, 0xBB, 0xAD, 0x72, 0x94, 0xCA,
0x40, 0x14, 0x55, 0xA1, 0x94, 0xA9, 0x49, 0xFA];

var ecdsa_pub_key_x = [
0x36, 0xDF, 0xE2, 0xC6, 0xF9, 0xF2, 0xED, 0x29,
0xDA, 0x0A, 0x9A, 0x8F, 0x62, 0x68, 0x4E, 0x91,
0x63, 0x75, 0xBA, 0x10, 0x30, 0x0C, 0x28, 0xC5,
0xE4, 0x7C, 0xFB, 0xF2, 0x5F, 0xA5, 0x8F, 0x52];

var ecdsa_pub_key_y = [
0x71, 0xA0, 0xD4, 0xFC, 0xDE, 0x1A, 0xB8, 0x78,
0x5A, 0x3C, 0x78, 0x69, 0x35, 0xA7, 0xCF, 0xAB,
0xE9, 0x3F, 0x98, 0x72, 0x09, 0xDA, 0xED, 0x0B,
0x4F, 0xAB, 0xC3, 0x6F, 0xC7, 0x72, 0xF8, 0x29];
 //DTLS_ECC_FEATURE end
//****************************************************************
// Module init start
//****************************************************************
dtls_create_sock('udp6');
//****************************************************************
//Module init end
//****************************************************************
function dtls_create_sock(type)
{
   if (!dtls_sock)
   {
      try
      {
         dtls_sock = dgram.createSocket(type, function(msg, rsinfo)  //Receive handshake packets from the DTLS peer
         {
            dtls_debug('DTLS packet received'); 
            var session = find_session(rsinfo.address);
            if (session)
            {
               session.rsinfo = rsinfo;
               dtls_handle_message(session, msg);               
            } 
         });
      }
      catch(e)
      {
         dtls_crit('DTLS socket creation failed: ' + e.toString());
      }
      
      /*
      try
      {
         dtls_sock.bind( dtls_config.DTLS_UDP_PORT );
      }
      catch(e)
      {
         dtls_crit('Cannot bind to the DTLS port '+ dtls_config.DTLS_UDP_PORT + ' : ' + e.toString());
      }  
      */
   }
}

function Dtls(role, opts)
{
   dtls_debug('Dtls(): ' + JSON.stringify(role));
   
   if (!opts)
   {
      opts = {};
   }
   if (!opts.type)
   {
      opts.type = 'udp4';
   }
   
   if (!opts.port)
   {
      opts.port = dtls_config.DTLS_UDP_PORT;
   }

   this.id = peerId++;
   this.host = null;
   this.role = role;
   this._opts = opts;
   this.connect = connect;
   this.encrypt = encrypt;
   this.decrypt = decrypt;
   this.close = close;
   this.find_session = find_session;
     
   dtls_debug('Dtls() exit');
   return this;
}

function Session(host, port, role, sock_type)
{
    this.host = host;
    this.port = port;
    this.role = role;
    this.type = sock_type;  
    this._sock = null;
    
    this.numberOfPeers = 0;
    this.numberOfConnectionAttempts = 0;
    this.numberOfConnectionSuccess = 0;
    this.numberOfConnectionTries = 0;
       
    this.reset = reset;  
    this.h = {};
    this.h.get_psk_info = get_psk_info;
    this.h.get_ecdsa_key = get_ecdsa_key;   //DTLS_ECC_FEATURE
    this.h.verify_ecdsa_key = verify_ecdsa_key;   //DTLS_ECC_FEATURE
    this.h.write = output_to_peer;
    this.psk = psk; 
    this._sock = dtls_sock; 
    
    this.reset();
	
	return this;
}

function reset()
{
    this.state = dtls_config.DTLS_STATE_INIT;
    this.timeout = 0;
    
    this.security_params_array = 
     [
        {
           compression: dtls_config.TLS_COMPRESSION_NULL, 
           cipher: dtls_config.TLS_NULL_WITH_NULL_NULL, 
           epoch: 0, 
           rseq:[], 
           key_block: [],
        },          
        {
           compression: dtls_config.TLS_COMPRESSION_NULL, 
           cipher: dtls_config.TLS_NULL_WITH_NULL_NULL, 
           epoch: 0, 
           rseq:[], 
           key_block: [],
        }
     ];
     
    this.security_index = 0;
    this.security_params_next = this.security_params_array[(this.security_index + 1) % 2];
    this.security_params = this.security_params_array[this.security_index];
  
    this.handshake_params = {hs_state: {}}; 
    this.handshake_params.hs_state.mseq_r = 0;
    this.handshake_params.hs_state.mseq_s = 0;
    this.handshake_params.hs_state.hs_hash = {};
    this.handshake_params.reorder_queue = [];
    this.handshake_params.tmp = {random:{client: [], server: []}, master_secret: []};
    this.handshake_params.keyx =
    {
       psk: 
       {
          identity: []
       },        
       ecdsa : 
       {
          own_eph_priv : [],
          other_eph_pub_x: [],
          other_eph_pub_y: [],
          other_pub_x: [],
          other_pub_y: []
       }
    }
    this.sendqueue = [];
    this.do_not_connect = false;
    
    this.c = dtls_new_context();
}

function find_session(host)
{
   dtls_debug('dtls.find_session() enter');
   var retVal = null; 
   if (host)
   {
	   var ip = ipaddr.parse(host).toNormalizedString();
	   
	   for (var i = 0; i < sessions.length; i++)
	   {
	      var ipi = ipaddr.parse(sessions[i].host).toNormalizedString();
	      if (ip.match(ipi, 128))
	      {
	         retVal = sessions[i];
	      }
	   }
   }
   dtls_debug('dtls.find_session() exit:' + retVal);
   return retVal;
}

function connect(host) 
{
   dtls_debug('dtls.connect() enter');
   var retV = false;
   if (!dtls_config.DISABLE_DTLS_FEATURE)
   {
	   if (this.reset_peer)
	   {
	      disconnect(host);
	      this.reset_peer = false;
	   }
	   
	   this.host = host;
	   var session = this.session ? this.session : this.find_session(this.host);
	      
	   if (!session)
	   {	  
	      session = sessions[sessions.length] = 
	    	  new Session(host, this._opts.port, this.role, this._opts.type);
	   }
	   
	   session.numberOfPeers++;
	   this.session = session;    

	   if (session.state == dtls_config.DTLS_STATE_INIT && session.role == dtls_config.DTLS_CLIENT)
	   {
	      //Start the connection process here
	      dtls_connect(this.session);
	   }	 
	   
	   retV = (session.state == dtls_config.DTLS_STATE_CONNECTED);
   }
   

   dtls_debug('dtls.connect() exit');
   return retV;
}


function disconnect(host) 
{
   dtls_debug('dtls.disconnect() enter');

   var ip = ipaddr.parse(host).toNormalizedString();
   
   for (var i = 0; i < sessions.length; i++)
   {
      var ipi = ipaddr.parse(sessions[i].host).toNormalizedString();
      if (ip.match(ipi, 128)) 
      {
         sessions.splice(i, 1); //delete the connection with the peer
      }
   }

   dtls_debug('dtls.disconnect() exit');
}
     
function output_to_peer(session, msg, outf)
{
   var retVal = msg.length;
   var message = Buffer.from(msg);
   var ackSent = function(err, bytes) 
   {
       dtls_debug("sent: " + err +","+ bytes);
    };
   
   dtls_debug('dtls.output_to_peer() enter: '+msg.length+' '+ session.port + ' ' + session.host);
   
   if (outf)
   {
      outf(msg, {address: session.host, port: session.port});
   }
   else
   {
      try
      {
    	 session._sock.send(message, 0, message.length, session.port, session.host, ackSent);
      }
      catch(e)
      {
         dtls_crit("DTLS sock.send() failed");
         return -1;
      }
   }
     
   dtls_debug('dtls.output_to_peer() exit:' + retVal);
   return retVal;
}

function encrypt(bmsg, rsinfo, outf)  //Encode the transmit data packets
{  
   dtls_debug("DTLS.send() enter: " + bmsg.length);
   var packetSentSuccess = false;
   var msg = Array.from(bmsg);
   
   if (!dtls_config.DISABLE_DTLS_FEATURE)
   {
	   this.host = rsinfo.address;
	   
	   if (this.reset_peer)
	   {
	      disconnect(this.host);
	      this.reset_peer = false;
	   }
	   
	   if (!this.session)
	   {    
	      //this is the first time send is called, need to check if a connection is already there
	      this.session = this.find_session(this.host);
	   }
	      
	   if (!this.session || this.session.state == dtls_config.DTLS_STATE_INIT)
	   {
	      if (!this.session)
	      {
	         dtls_crit("this.session null");
	      }
	      else
	      {
	         dtls_debug("this.session.state:" + this.session.state);
	      }
	      this.connect(rsinfo.address);     
	   }
	   else if (this.session.state == dtls_config.DTLS_STATE_CONNECTED )
	   {
		  packetSentSuccess = dtls_write(this.session, msg, outf); 
	   }    
   }
 
   if (packetSentSuccess)
   {
      dtls_debug("DTLS encrypt success");
   }
   else
   {
      outf(msg, rsinfo);
   }
   
   dtls_debug("DTLS.send() exit: " + packetSentSuccess);
   return packetSentSuccess;
}

function decrypt(rsinfo, msg, outbuf)
{
   dtls_debug("DTLS.decrypt() enter");
   if (this.session && rsinfo.port == this.session.port)     //fengmo dtls:
   {
      this.session.rsinfo = rsinfo;
      dtls_handle_message(this.session, msg, outbuf); 
   }
   else
   {
	  memcpy(outbuf, msg, msg.length); 
   }
   dtls_debug("DTLS.decrypt() exit");
}

function get_psk_info(session, type, id)
{
   var result = null;

   switch(type)
   {
   case dtls_config.DTLS_PSK_KEY:
      if (id != null) 
      {  
         for (var i = 0; i < session.psk.length; i++)
         {
            if (id.length == session.psk[i].id.length)
            {  
               var match = true;
               for (var j = 0; j < id.length; j++)
               {
                  if (id[j] != session.psk[i].id[j])
                  {
                     match = false;
                     break;
                  }
               }
               if (match)
               {
                  result = session.psk[i].key.slice(0, session.psk[i].key.length);
                  break;
               }
            }
         }
      }
      
      break;
   
   case dtls_config.DTLS_PSK_IDENTITY:  
      result = session.psk[0].id.slice(0, session.psk[0].id.length);      
      break;
   
   default:
      break;
   }

   return result;
}
 //DTLS_ECC_FEATURE begin
function get_ecdsa_key(session, result) 
{
   result.curve = dtls_config.DTLS_ECDH_CURVE_SECP256R1;
   result.priv_key = ecdsa_priv_key;
   result.pub_key_x = ecdsa_pub_key_x;
   result.pub_key_y = ecdsa_pub_key_y;

   return 0;
}

function verify_ecdsa_key(session, other_pub_x, other_pub_y, key_size) 
{
  return 0;
}
 //DTLS_ECC_FEATURE end
function close()
{
   dtls_debug('dtls.close()');
   if (this.session)
   {
      this.session.numberOfPeers--;
      this.session = null;
   }      
   this.host = null;
}

module.exports = Dtls; 
