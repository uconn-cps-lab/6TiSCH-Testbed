/*
 * Copyright (c) 2015-2016, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

function define(name, value) {
    Object.defineProperty(exports, name, {
        value:      value,
        enumerable: true
    });
}

define("DISABLE_DTLS_FEATURE",               true);  //DTLS will be disabled if set to true
define("DTLS_PSK_SUPPORT",                   false);  //DTLS_ECC_FEATURE
define("DTLS_ECC_SUPPORT",                   true);   //DTLS_ECC_FEATURE

define("KEEP_TRY_CONNECTION",                false);  //Do not keep try the connection attempts forever 
define("DTLS_UDP_PORT",                      20220);
define("PSK_ID_MAXLEN",                      32);
define("PSK_DEFAULT_IDENTITY", Array.from(Buffer.from("Client_identity")));
define("PSK_DEFAULT_KEY",      Array.from(Buffer.from("secretPSK")));
    
define("DTLS_PSK_HINT",       0);
define("DTLS_PSK_IDENTITY",   1);
define("DTLS_PSK_KEY",        2);

define("DTLS_STATE_INIT",                    0);
define("DTLS_STATE_WAIT_CLIENTHELLO",        1);
define("DTLS_STATE_WAIT_CLIENTCERTIFICATE",  2);
define("DTLS_STATE_WAIT_CLIENTKEYEXCHANGE",  3);
define("DTLS_STATE_WAIT_CHANGECIPHERSPEC",   4);
define("DTLS_STATE_WAIT_FINISHED",           5);
define("DTLS_STATE_FINISHED",                6);
define("DTLS_STATE_CLIENTHELLO",             7);
define("DTLS_STATE_WAIT_SERVERCERTIFICATE",  8);
define("DTLS_STATE_WAIT_SERVERKEYEXCHANGE",  9);
define("DTLS_STATE_WAIT_SERVERHELLODONE",    10);
define("DTLS_STATE_CONNECTED",               11);
define("DTLS_STATE_CLOSING",                 12);
define("DTLS_STATE_CLOSED",                  13);

define("DTLS_CLIENT",                        0);
define("DTLS_SERVER",                        1);

define("DTLS_CCM_BLOCKSIZE",                 16);  /**< size of hmac blocks */

define("TLS_NULL_WITH_NULL_NULL",            0x0000);   /**< NULL cipher  */
define("TLS_PSK_WITH_AES_128_CCM_8",         0xC0A8); /**< see RFC 6655 */
define("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xC0AE); /**< see RFC 7251 */

define("DTLS_VERSION",                       0xFEFD); /* DTLS v1.2 */

define("CLOCK_SECOND",                       1000);  //clock tick = 1 msec
define("RETRANSMIT_TIMEOUT",                 (80*this.CLOCK_SECOND)); //seconds

define("DTLS_HMAC_BLOCKSIZE",                64); /**< size of hmac blocks */
define("DTLS_HMAC_DIGEST_SIZE",              32); /**< digest size (for SHA-256) */
define("DTLS_HMAC_MAX",                      64); /**< max number of bytes in digest */

define("DTLS_MAC_KEY_LENGTH",                0);
define("DTLS_KEY_LENGTH",                    16); /* AES-128 */
define("DTLS_BLK_LENGTH",                    16); /* AES-128 */
define("DTLS_MAC_LENGTH",                    this.DTLS_HMAC_DIGEST_SIZE);
define("DTLS_IV_LENGTH",                     4);  /* length of nonce_explicit */
define("DTLS_CCM_NONCE_SIZE",                12);   /**< size of nonce */
define("DTLS_COOKIE_SECRET_LENGTH",          12);
define("DTLS_COOKIE_LENGTH_MAX",             32);

define("DTLS_ALERT_CLOSE_NOTIFY",            0);         /* close_notify */
define("DTLS_ALERT_UNEXPECTED_MESSAGE",      10);    /* unexpected_message */
define("DTLS_ALERT_BAD_RECORD_MAC",          20);      /* bad_record_mac */
define("DTLS_ALERT_RECORD_OVERFLOW",         22);     /* record_overflow */
define("DTLS_ALERT_DECOMPRESSION_FAILURE",   30);  /* decompression_failure */
define("DTLS_ALERT_HANDSHAKE_FAILURE",       40);      /* handshake_failure */
define("DTLS_ALERT_BAD_CERTIFICATE",         42);     /* bad_certificate */
define("DTLS_ALERT_UNSUPPORTED_CERTIFICATE", 43);   /* unsupported_certificate */
define("DTLS_ALERT_CERTIFICATE_REVOKED",     44);    /* certificate_revoked */
define("DTLS_ALERT_CERTIFICATE_EXPIRED",     45);    /* certificate_expired */
define("DTLS_ALERT_CERTIFICATE_UNKNOWN",     46);    /* certificate_unknown */
define("DTLS_ALERT_ILLEGAL_PARAMETER",       47);      /* illegal_parameter */
define("DTLS_ALERT_UNKNOWN_CA",              48);       /* unknown_ca */
define("DTLS_ALERT_ACCESS_DENIED",           49);    /* access_denied */
define("DTLS_ALERT_DECODE_ERROR",            50);        /* decode_error */
define("DTLS_ALERT_DECRYPT_ERROR",           51);    /* decrypt_error */
define("DTLS_ALERT_PROTOCOL_VERSION",        70);    /* protocol_version */
define("DTLS_ALERT_INSUFFICIENT_SECURITY",   71);  /* insufficient_security */
define("DTLS_ALERT_INTERNAL_ERROR",          80);      /* internal_error */
define("DTLS_ALERT_USER_CANCELED",           90);    /* user_canceled */
define("DTLS_ALERT_NO_RENEGOTIATION",        100);      /* no_renegotiation */
define("DTLS_ALERT_UNSUPPORTED_EXTENSION",   110);  /* unsupported_extension */

define("DTLS_MASTER_SECRET_LENGTH",          48);
define("DTLS_RANDOM_LENGTH",                 32);
define("TLS_EXT_ELLIPTIC_CURVES",            10); /* see RFC 4492 */
define("TLS_EXT_EC_POINT_FORMATS",           11); /* see RFC 4492 */
define("TLS_EXT_SIG_HASH_ALGO",              13); /* see RFC 5246 */
define("TLS_EXT_CLIENT_CERTIFICATE_TYPE",    19); /* see RFC 7250 */
define("TLS_EXT_SERVER_CERTIFICATE_TYPE",    20); /* see RFC 7250 */
define("TLS_EXT_ENCRYPT_THEN_MAC",           22); /* see RFC 7366 */
define("TLS_CERT_TYPE_RAW_PUBLIC_KEY",       2); /* see RFC 7250 */
define("TLS_EXT_ELLIPTIC_CURVES_SECP256R1",  23); /* see RFC 4492 */
define("TLS_EXT_EC_POINT_FORMATS_UNCOMPRESSED", 0); /* see RFC 4492 */
define("TLS_EC_CURVE_TYPE_NAMED_CURVE",      3); /* see RFC 4492 */
define("TLS_CLIENT_CERTIFICATE_TYPE_ECDSA_SIGN",   64); /* see RFC 4492 */
define("TLS_EXT_SIG_HASH_ALGO_SHA256",       4); /* see RFC 5246 */
define("TLS_EXT_SIG_HASH_ALGO_ECDSA",        3); /* see RFC 5246 */

define("DTLS_CT_CHANGE_CIPHER_SPEC",   20);
define("DTLS_CT_ALERT",                21);
define("DTLS_CT_HANDSHAKE",            22);
define("DTLS_CT_APPLICATION_DATA",     23);

define("DTLS_HT_HELLO_REQUEST",              0);
define("DTLS_HT_CLIENT_HELLO",               1);
define("DTLS_HT_SERVER_HELLO",               2);
define("DTLS_HT_HELLO_VERIFY_REQUEST",       3);
define("DTLS_HT_CERTIFICATE",                11);
define("DTLS_HT_SERVER_KEY_EXCHANGE",        12);
define("DTLS_HT_CERTIFICATE_REQUEST",        13);
define("DTLS_HT_SERVER_HELLO_DONE",          14);
define("DTLS_HT_CERTIFICATE_VERIFY",         15);
define("DTLS_HT_CLIENT_KEY_EXCHANGE",        16);
define("DTLS_HT_FINISHED",                   20);

define("DTLS_ALERT_LEVEL_WARNING",           1);
define("DTLS_ALERT_LEVEL_FATAL",             2);

define("SHA256_BLOCK_LENGTH",                64);
define("SHA256_SHORT_BLOCK_LENGTH",          (this.SHA256_BLOCK_LENGTH - 8));
define("DTLS_RH_LENGTH",                     13);

define("DTLS_EVENT_CONNECT",                 0x01DC); /**< initiated handshake */
define("DTLS_EVENT_CONNECTED",               0x01DE); /**< handshake or re-negotiation has finished */
define("DTLS_EVENT_RENEGOTIATE",             0x01DF); /**< re-negotiation has started */
define("TLS_COMPRESSION_NULL",               0); 

define("DTLS_HS_LENGTH",                     12);
define("DTLS_HV_LENGTH",                     3);


define("DTLS_EC_KEY_SIZE",                   32);
define("DTLS_PSK_MAX_CLIENT_IDENTITY_LEN",   32);
define("DTLS_CH_LENGTH",                     34); /* no variable length fields! */
define("DTLS_CH_LENGTH_MAX",                 this.DTLS_CH_LENGTH + this.DTLS_COOKIE_LENGTH_MAX + 12 + 26);
define("DTLS_SH_LENGTH",                     (2 + this.DTLS_RANDOM_LENGTH + 1 + 2 + 1));
define("DTLS_CE_LENGTH",                     (3 + 3 + 27 + this.DTLS_EC_KEY_SIZE + this.DTLS_EC_KEY_SIZE));
define("DTLS_SKEXEC_LENGTH",                 (1 + 2 + 1 + 1 + this.DTLS_EC_KEY_SIZE + this.DTLS_EC_KEY_SIZE + 1 + 1 + 2 + 70));
define("DTLS_SKEXECPSK_LENGTH_MIN",          2);
define("DTLS_SKEXECPSK_LENGTH_MAX",          2 + this.DTLS_PSK_MAX_CLIENT_IDENTITY_LEN);
define("DTLS_CKXPSK_LENGTH_MIN",             2);
define("DTLS_CKXEC_LENGTH",                  (1 + 1 + this.DTLS_EC_KEY_SIZE + this.DTLS_EC_KEY_SIZE));
define("DTLS_CV_LENGTH",                     (1 + 1 + 2 + 1 + 1 + 1 + 1 + this.DTLS_EC_KEY_SIZE + 1 + 1 + this.DTLS_EC_KEY_SIZE));
define("DTLS_FIN_LENGTH",                    12);

define("prf_label_master",                   Array.from(Buffer.from("master secret")));
define("prf_label_key",                      Array.from(Buffer.from("key expansion")));
define("prf_label_client",                   Array.from(Buffer.from("client")));
define("prf_label_server",                   Array.from(Buffer.from("server")));
define("prf_label_finished",                 Array.from(Buffer.from(" finished")));
define("SHA256_DIGEST_LENGTH",               32);
define("HASH_SHA256",                        4);
define("DTLS_DEFAULT_MAX_RETRANSMIT",        0);
define("MAX_CONNECTION_TRIES",               3);   //Max number of connection tries to a peer before concluding DTLS is not supported
define("MAX_KEYBLOCK_LENGTH",                (2 * this.DTLS_MAC_KEY_LENGTH + 2 * this.DTLS_KEY_LENGTH + 2 * this.DTLS_IV_LENGTH));

module.exports.memset = function(x, v, l, xoff)
{
   var xo = xoff ? xoff : 0;
   for (var i = 0; i < l; i++)
   {
      x[i+xo] = v;
   }
}

module.exports.memcpy = function(y, x, l, yoff, xoff)
{
   var yo = yoff ? yoff : 0;
   var xo = xoff ? xoff : 0;
   for (var i = 0; i < l; i++)
   {
      y[i+yo] = x[i+xo];
   }
}

module.exports.memcmp = function(x, y, l, yoff, xoff)
{
   var retv = 0;
   var yo = yoff ? yoff : 0;
   var xo = xoff ? xoff : 0;
   for (var i = 0; i < l; i++)
   {
      if (y[i+yo] != x[i+xo])
      {
         retv = 1;
         break;
      }
   }
   
   return retv;
}

module.exports.dtls_info = function(msg)
{
   console.log(msg);
}

module.exports.dtls_warn = function(msg)
{
   console.log(msg);
}

module.exports.dtls_debug = function(msg)
{
   //console.log(msg);
}

module.exports.dtls_crit = function(msg)
{
   console.log(msg);
}

module.exports.dtls_alert = function(msg)
{
   console.log(msg);
}

/* this one is for consistency... */
module.exports.dtls_int_to_uint8 = function(value)
{
   var field = [value % 0x100];
   return field;
}

module.exports.dtls_int_to_uint16 = function(value)
{
   var field = [Math.floor(value / 0x100) % 0x100, value % 0x100];
   return field;
}

module.exports.dtls_int_to_uint24 = function(value)
{
   var field = [];
   field[0] = Math.floor(value / 0x10000) % 0x100;
   field[1] = Math.floor(value / 0x100) % 0x100;
   field[2] = value % 0x100;
   return field;
}

module.exports.dtls_int_to_uint32 = function(value)
{
   var field = [];
   field[0] = Math.floor(value / 0x1000000) % 0x100;
   field[1] = Math.floor(value / 0x10000) % 0x100;
   field[2] = Math.floor(value / 0x100) % 0x100;
   field[3] = value % 0x100;
   return field;
}

module.exports.dtls_int_to_uint48 = function(value)
{
   var field = [];
   field[0] = Math.floor(value / 0x10000000000) % 0x100;
   field[1] = Math.floor(value / 0x100000000) % 0x100;
   field[2] = Math.floor(value / 0x1000000) % 0x100;;
   field[3] = Math.floor(value / 0x10000) % 0x100;;
   field[4] = Math.floor(value / 0x100) % 0x100;;
   field[5] = value % 0x100;
   return field;
}

module.exports.dtls_uint8_to_int = function(field)
{
  return field[0];
}

module.exports.dtls_uint16_to_int = function(field)
{
   return (field[0]*0x100 + field[1]);
}

module.exports.dtls_uint24_to_int = function(field)
{
   return (field[0]*0x10000 + field[1]*0x100  + field[2]);
}

function dtls_uint32_to_int(field)
{
  return (field[0]*0x1000000)
    + (field[1]   *0x10000)
    + (field[2]   *0x100)
    + field[3];
}

function dtls_prng(len)
{
   var buf = [];
   
   for (var i = 0; i < len; i++)
   {
      buf[i] = Math.floor(0xFF*Math.random());
   }
   return buf;
}

module.exports.dtls_prng_uint32 = function(len)
{      
   var tbuf = dtls_prng(len);
   var rand = [];
   for (var i = 0; i < len; i+= 4)
   {
      rand.push(dtls_uint32_to_int(tbuf.slice(i, i+4)));
   }
   return rand;
}

module.exports.dtls_uint32_to_int   = dtls_uint32_to_int;
module.exports.dtls_prng            = dtls_prng;
module.exports.content_types = 
[  
   this.DTLS_CT_CHANGE_CIPHER_SPEC,
   this.DTLS_CT_ALERT,
   this.DTLS_CT_HANDSHAKE,
   this.DTLS_CT_APPLICATION_DATA
]
